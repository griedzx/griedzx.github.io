[{"categories":[],"content":"人类基因组计划（HGP） 目标：整体上破解人类遗传信息的奥秘 测序数据：30亿个碱基对，2~3万个基因，约3个G 四个图：遗传图、物理图、序列图、基因图 ","date":"2024-01-11","objectID":"/intro/:0:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"测序技术 sanger测序步骤 分离待测核酸样本 在反应体系中加入适当引物、模板、DNA聚合酶、dNTP、带荧光标记的ddNTP DNA合成 凝胶电泳分离反应产物 放影自显影 Illumina 在小型芯片上进行桥式PCR反应,每次只合成一个碱基，并标记荧光基团,再利用相应的激光激发荧光基团，捕获激发光，从而读碱基信息 可以很好解决同聚物长度的准确测量问题 碱基的替换会造成测序错误且读取序列较短给de novo sequencing拼接带来困难 代表 测序基础 优点 缺点 一代测序 sanger(合成终止测序) ddNTP为测序反应的链终止剂 准确率高 读长较长 可达1000bp 电泳分离速度低 成本难以降低 二代测序 454 Illumina SOLiD 单个小片段DNA分子结合到固相表面 扩增复制检测信号 较一代测序 降低成本 准确率较高 测序时间较快 读长短 （DNA簇中存在光学信号移项） 三代测序 PacBio-SMRT Oxford-Nanopore 单分子测序技术 DNA聚合酶和模板结合,4色荧光标记 4 种碱基 在碱基配对阶段,不同碱基的加入,会发出不同光 读长较长，减少拼接成本 降低内存和计算时间 原理长避免pcr扩增引入错误 依赖DNA聚合酶活性 成本昂贵 一、二、三代测序技术的比较 第一代和第二代测序技术除了通量和成本上的差异之外，其测序核心原理（除Solid是边连接边测序之外）都是基于边合成边测序的思想。第二代测序技术的优点是成本较之一代大大下降，通量大大提升，但缺点是所引入PCR过程会在一定程度上增加测序的错误率，并且具有系统偏向性，同时读长也比较短。第三代测序技术是为了解决第二代所存在的缺点而开发的，它的根本特点是单分子测序，不需要任何PCR的过程，这是为了能有效避免因PCR偏向性而导致的系统错误，同时提高读长，并要保持二代技术的高通量，低成本的优点。 ","date":"2024-01-11","objectID":"/intro/:1:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"数据库 哪些数据可用于创建生物信息学数据库？ ①核苷酸序列（DNA或RNA的测序原始数据、基因组组装序列等） ②蛋白质序列与结构信息 ③序列与结构注释信息（基因注释、功能注释） ④代谢路径信息（底物、产物、酶等） 生物信息学数据库 核酸数据库: 三大核酸数据库：GenBank（美）， ENA（欧），DDBJ（日） 基因组数据库: Genome 高通量测序相关数据库: ①BioProject：提交到NCBI的各种数据的项目描述 ②BioSample：提交到NCBI的各种数据的样品描述 ③SRA：存放高通量测序数据 ④Assembly：各种基因组拼接的不同版本及信息 蛋白质数据库 ①蛋白质序列数据库 UniProt 包含UniProtKB、UniRef、UniParc UniProtKB可分为两个部分： 来源于实验的有详细注释的序列（SWISS-PROT） 和自动注释序列（TrEMBL） TrEMBL是自动化翻译获得的蛋白质数据库，不含二级结构信息 ②蛋白质结构数据库——RCSB:PDB ③蛋白质功能域数据库 PROSITE ：收集了生物学有显著意义的蛋白质位点和序列模式，并能根据这些位点和模式快速可靠地鉴别一个未知蛋白质序列应该属于哪一些蛋白质家族 Pfam ：蛋白质家族数据库，根据多序列比对和隐马可夫模型将蛋白质分为不同家族 NCBI数据库搜索过程中精简检索结果可以应用： 1） 使用Advanced search 2） 使用Limit 3） 直接输入搜索字段 4） 组合多次搜索结果 5） 不断增加关键词 ","date":"2024-01-11","objectID":"/intro/:2:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"双序列比对 ","date":"2024-01-11","objectID":"/intro/:3:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"经典算法 全局比对 NW算法 局部比对 SW算法 gap 矩阵中横向移动则纵向表示的序列新增’-’,反之横向新增 ","date":"2024-01-11","objectID":"/intro/:3:1","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"打分矩阵的构建以及异同 DNA替换矩阵 PAM 根据碱基环结构环数不同分为嘧啶和嘌呤，环数改变为颠换，环数不变为转换 氨基酸替换矩阵 PAM PAM-n中，n 越小，表示氨基酸变异的可能性越小；相似的序列之间比较应该选用n值小的矩阵，不太相似的序列之间比较应该选用n值大的矩阵（PAM-250用于约20%相同序列之间的比较）。 BLOSUM 亲缘关系较远蛋白质 BLOSUM-n中，n越小，表示氨基酸相似的可能性越小；相似的序列之间比较应该选用 n 值大的矩阵，不太相似的序列之间比较应该选用n值小的矩阵（BLOSUM62用于约62%相同序列之间的比较） 若双序列比对中，比对序列过长或者需要进行两两比对的序列多（搜库），还有其他算法 Blast 基因组序列比对 短序列比对 ","date":"2024-01-11","objectID":"/intro/:3:2","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"BLAST比对 基本原理 为序列A构建一个k-mer/k-tuple哈希表 扫描序列B，找到hits(比对后得分大于t的片段) 扩展hits(使用SW算法扩展高得分片段对HSPS，这些片段的分值不会因为片段的延申而进一步升高) 一致性(identity)：两条序列在同一位点上的核苷酸或者氨基酸残基完全相同 同源性(homoogy)：两条序列存在进化方面的关系，它们从一条共同的祖先序列进化而来。同源可以分为直系同源和旁系同源 相似性：两条序列在同一位点上的氨基酸残基的化学性质相似。相似性可以用百分比描述，但同源性不可以 ","date":"2024-01-11","objectID":"/intro/:3:3","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"PSSM ","date":"2024-01-11","objectID":"/intro/:3:4","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"信息熵 ","date":"2024-01-11","objectID":"/intro/:3:5","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"重测序 重测序分析是对已知基因组序列的物种进行DNA测序，并在此基础上完成个体或群体基因组层面上的分析。 ","date":"2024-01-11","objectID":"/intro/:3:6","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"序列拼接（基因组装）和短序列比对 ","date":"2024-01-11","objectID":"/intro/:4:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"如何获得全基因组（组装）的序列 BAC by BAC shotgun ","date":"2024-01-11","objectID":"/intro/:4:1","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"基于Kmer分析，评估基因组大小 设基因组大小为G，测序获得N条read，且每条长度均为L 故k-mer总数为：Knum = (L-K+1)*N k-mer的期望测序深度为：Kdepth = [(L-K+1)/G]*N 则G = Knum / Kdepth ","date":"2024-01-11","objectID":"/intro/:4:2","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"基因组序列组装的主要步骤 ①选择一种或多种测序技术，对目标基因组测序 ②基于测序数据，从头组装，得到contig序列 ③使用一种或多种组学技术，将contig序列进一步连接，得到scaffold序列 ④将scaffold序列定位到染色体上 ","date":"2024-01-11","objectID":"/intro/:4:3","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"二、三代测序数据在组装中的应用和各自优势 主流： 三代测序数据搭建contig 二代短片段数据纠错 利用BioNano/Hi-C等技术将contig连接成scaffold或者染色体水平 三代测序技术中PacBio可以 克服序列中高GC含量或者重复序列多，以精细基因注释 长片段填补二代测序数据组装中的gap以及连接contig成scaffold ","date":"2024-01-11","objectID":"/intro/:4:4","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"de Bruijn graph 将基因组组装问题转化为寻找欧拉超路的问题 ","date":"2024-01-11","objectID":"/intro/:4:5","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"SOAPdenovo 组装原理及使用 ①构建测序文库 ②序列k-mer化，构建de Bruijn图 ③简化de Bruijn图 ④确定断点并输出contig ⑤构建scaffold序列 ⑥填充gap ","date":"2024-01-11","objectID":"/intro/:4:6","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"基于三代长片段测序数据的从头组装流程 ①比对测序原始读段 ②纠正原始读段错误 ③组装纠正后的读段 ④纠正组装后的contig序列 ","date":"2024-01-11","objectID":"/intro/:4:7","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"组装质量评估 3c原则 组装连续性 contiguity N50/N90 数值越大，组装效果越好 L50/L90 数值越小，组装效果越好 组装完整度 completeness 读段回帖 组装读段重新比对会基因组，理论上能比对上的读段的比例越高，则组装完整性越好效果越好 LAI BUSCO CEGMA 将某些物种共有的保守基因，比对到或通过其它方法检索基因组，根据能检索出的基因数量 K-mer 通过比较用于组装的测序读段含有的Kmer集合，与组装好的序列含有的Kmer集合，评估基因组组装的完整性 组装准确率 correctness 读段回帖 K-mer ","date":"2024-01-11","objectID":"/intro/:4:8","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"短序列比对 BWT 编码 对L列进行从小到大排序得到F列 解码 ","date":"2024-01-11","objectID":"/intro/:4:9","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"分子进化与系统发育 ","date":"2024-01-11","objectID":"/intro/:5:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"隐马科夫模型（HMM）和基因组注释 学习问题：向前向后算法（EM） ","date":"2024-01-11","objectID":"/intro/:6:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"原核生物和真核生物基因组的特点及异同 原核基因组特点：染色体多为一条环状闭合双链DNA，编码序列占基因组总长度的90%，CG含量在16.6%-74.9%，DNA链组成的非对称分布 原核生物基因结构： 启动子-转录位点-5‘UTR-起始密码子-编码区-终止密码子-3’UTR-终止区 真核基因组特点 对基因预测影响 ","date":"2024-01-11","objectID":"/intro/:6:1","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"基因定位和全基因组关联分析 QTL,数量性状:在一个群体内表现为连续变异的形状，相对性状间没有质的差异 分子标记：以个体间遗传物质的核苷酸序列变异为基础的遗传标记，优点在于不变，稳定可靠以及数量丰富 southern杂交 PCR扩增 单核苷酸多态性 ","date":"2024-01-11","objectID":"/intro/:7:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"QTL 代表染色体上影响数量性状的某个区段，区段内可能有一个甚至多个影响数量性状的功能基因 QTL定位原理 当标记和控制特定性状基因连锁时，不同标记基因型的表型值存在显著差异，通过表型与标记间关联分析，来确定控制数量性状的基因在染色体上的位置和效应 目的：定位影响数量性状的功能基因 QTL基本步骤 分离世代群体建立 遗传标记检测和表型测定 QTL统计分析 单标记分析 区间作图法 复合区间作图法 候选基因鉴定 LOD值与阈值确定 LOD log10(L1/L0)，L1是该位点有QTL的概率，L0是该位点无QTL的概率。如果LOD=2，则意味着这个位点有QTL的概率是无QTL的概率的10^2倍。 LOD置信区间 QTL定位的结果是1个LOD值在染色体上变化的波形图，QTL区域的LOD值会形成一个信号峰，功能基因通常是位于这个区间内 为了便于后续研究中筛选候选基因，我们通常会设置一个范围筛选候选基因。一般经验值会使用2-LOD置信区间 2-LOD置信区间就是LOD波动曲线从峰的最大值降低2的时候(Y轴), 对应在遗传图谱上跨越的区域(X轴)。2-LOD置信区间大概对应99.8%的置信区间，即功能基因有99.8%概率已经落在这个区域内了 显著性阈值的确定 ","date":"2024-01-11","objectID":"/intro/:7:1","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"Permutation test 无放回的数据重复抽样方法 不做permutation test时可以用人为给定的阈值：LOD \u003e 2-3 ","date":"2024-01-11","objectID":"/intro/:7:2","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"GWAS 原理 SNP与表型的相关联，如果SNP与表现型两个维度协同变化，就可以推测这个SNP位点极有可能与表型相关 优点 标记密度高，理论上可获得群体中所有的变异，并能利用历史上的重组，因而具有较高的定位精度 具有丰富的变异，与人工构建的群体变异来源两个或少数几个亲本相比，自然群体中的变异来自于几百上千乃至数十万的个体 快速简便，无需构建群体耗时 ","date":"2024-01-11","objectID":"/intro/:7:3","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"缺点 标记数目多，运算量较大 较复杂的遗传背景，造成较高的假阳性和假阴性 不同频率的变异检出效率不同，只能检出常见变异 群体结构 由于个体之间非随机交配而导致的群体中亚群之间等位基因频率的系统差异。即：存在大量物理位置上离得远的LD位点 影响：由于等位基因频率在亚群中可能不同，因此群体分层可能导致假阳性关联，会降低克隆基因定位的精度 混合线性模型 在方差分析模型中既包括固定效应，还包括随机效应的模型 GWAS使用混合线性模型： 一般的简单线性模型只能分析表型受某一基因影响，但实际上大多数表型都受到许多不同的基因影响。 混合线性模型添加了随机效应以校正遗传背景，能判断表型受多个基因影响，更符合多基因假说。 混合线性模型通过校正群体结构和群体内复杂的亲缘关系来分析标记和表型的相关性，有效控制人口结构和近交效应的影响 亲缘关系矩阵（Kinship） 量化群体结构的矩阵，用来校正群体内复杂的亲缘关系 (1)控制人口结构和近交效应 (2)估计随机效应 (3)处理缺失数据 LD 连锁不平衡 群体中不同位点的等位基因间的非随机关联现象 连锁是指位于同一染色体上的基因具有一起遗传的倾向（物理上接近） 连锁不平衡（LD）是指分属两个或两个以上基因座位的等位基因同时出现的几率，高于随机出现的频率 LD（不一定物理上接近，不同染色体上的位点由于遗传漂变等可产生连锁不平衡） 曼哈顿图 \u0026 QQ-plot 曼哈顿图 GWAS分析之后的所有SNP位点的p-value在整个基因组上展示出来，一般Y轴使用-log10(p-value)，Y轴的高度就对应了表型和位点的关联程度。Y轴值越大，p-value越小，位点和表型的关联程度越大。 qq-plot 评估GWAS结果中的关联统计量是否偏离了预期的分布 因为可能存在自然选择和遗传漂变导致基因位点突变。如果不存在突变情况，则p-value的分布和均匀分布结果应该集中在同一条直线上；如果存在突变，那么当p-value越小时两种概率分布的分离程度越高，QQ图会翘起来。 ","date":"2024-01-11","objectID":"/intro/:7:4","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"缺失基因型填补 基因型缺失一般分为两种， 遗传性缺失：个体遗传信息的变异（例如，位点DNA片段真实缺失）导致的基因型缺失， 检测性缺失：由于检测技术的局限、错误等导致的信息丢失， 基于参考群体已有的基因型，预测目标个体未进行基因分型的位点的基因型 ","date":"2024-01-11","objectID":"/intro/:7:5","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"决定GWAS和QTL定位精度的因素 最根本的因素：重组事件的数目：重组事件越多，最小重组片段越小，定位精度越高 可推及的其他因素： 分级标记的密度：当分子标记数比重组事件多时才能更好的检出重组 群体大小：群体越大包含的重组事件越多 群体结构：群体隔离与自然选择都会降低重组率 群体的类型：不同的群体重组率差别很大，是否有杂合基因型也有影响 表型的遗传率和测量误差以及检测方法 模型的选择（线性模型/混合模型） 位点之间是否存在复杂的互作 ","date":"2024-01-11","objectID":"/intro/:7:6","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"基因芯片和表达谱分析 ","date":"2024-01-11","objectID":"/intro/:8:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"芯片实验 全过程 提取RNA 反转录（扩增） 标记 杂交 扫描 获得原始数据 基因芯片实验局限性和优点 优点 稳定可靠（RNA-seq测序量高对低表达基因的定量才可靠） 积累了大量不可重新获取的数据 局限性 只能检测已知或确定性的序列 无法检测新发现的、未放置到芯片上的基因 有部分探针的信号可能会受到非特异性杂交及个体序列差异的影响 ","date":"2024-01-11","objectID":"/intro/:8:1","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"M-A plot 总结了样本在信号强度或读取计数方面的差异 用于确定是否需要均一化，可以绘制芯片数据中信号值x和y的图，并查看直线的斜率是否在1左右 以2为底取对数的原因： 一般认为一个基因在两个不同样本中表达量差异到两倍时是差异基因，取对数是为了便于作图观测 ","date":"2024-01-11","objectID":"/intro/:8:2","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"芯片实验前处理 步骤 数据过滤 背景纠正 均一化 汇总 补缺失值（imputation） 批次效应 均一化 中值均一化 分位数均一化 Quantile Normalization 求行平均数 排序 归位 汇总 得到每个基因的单个强度值 中值平滑法 减去行中位数，减去列中位数，循环重复直至行列中值均为0，所得为残差矩阵，raw-residual = 拟合矩阵 ","date":"2024-01-11","objectID":"/intro/:8:3","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"差异表达分析 多重检验假设 Permutation 差异表达基因鉴定中作用: 差异表达基因鉴定的目标是确定在不同条件或组之间是否存在基因表达水平的显著差异。传统的假设检验方法（如t检验或方差分析）通常要求数据满足特定的假设前提，如正态分布或方差齐性。然而，在基因表达数据中，由于其特殊性质（高维度、非对称分布等），这些假设不一定成立。 排列检验的优势在于它不依赖于特定的分布假设，适用于各种类型的基因表达数据。它可以对不同样本间的差异进行准确的统计推断，并提供基于实际数据分布的显著性评估。排列检验在差异表达基因鉴定中广泛应用，帮助研究人员发现在不同条件下具有显著表达差异的基因，以及进行相关的统计推断和生物学解释。 ","date":"2024-01-11","objectID":"/intro/:8:4","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"聚类分析 表达谱聚类通常使用什么作为距离？ 基因的表达量用欧氏距离聚类，会将表达量类似的基因聚一起 基因的表达量用1-cor作为距离聚类，表达模式类似的基因聚一起 最主要的目的是查看差异基因的表达模式，所以推荐用1-cor作为距离；也可表达量行均一化（row-scale）后用欧氏距离聚类 KNN算法：假设样本A的基因G表达量缺失 ①找到所有样品中与基因G表达量最相关的J个基因 ②根据这J个基因的表达量计算样品间距离，找到与样品A距离最小、基因G表达量有值的K个样品 ③计算这K个样品的基因G的表达量的平均值，填补缺失值 在KNN算法中，距离的定义以及K的选择十分重要 ","date":"2024-01-11","objectID":"/intro/:8:5","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"基因的本体论（Gene Ontology）及其三大分类 ","date":"2024-01-11","objectID":"/intro/:8:6","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"蛋白质结构和功能预测 ","date":"2024-01-11","objectID":"/intro/:9:0","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"蛋白质结构 一级结构：氨基酸的排列顺序 二级结构：主要由氢键维系的结果（α-helix、β-sheet、转角、环、无规则卷） 三级结构：二级结构进一步折叠形成的结构域 四级结构：多个亚基之间的空间结构 ","date":"2024-01-11","objectID":"/intro/:9:1","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"二级结构预测 每一段相邻的氨基酸残基具有形成一定二级结构的倾向 各种二级结构非均匀分布在蛋白质中 二级结构预测问题时模式分类问题 预测方法 第一代：统计学方法 1.基于单个氨基酸残基统计分析 根据每种氨基酸出现在各种二级结构中倾向或者频率是不同的，通过统计分析，获得的每个残基出现于特定二级结构构象的倾向性因子利用倾向性因子预测蛋白质的二级结构 2.基于氨基酸片段的统计分析（GOR） 如通过疏水氨基出现的周期性规律预测蛋白质的二级结构 当在一段序列中发现第i，i+3，i+4是疏水氨基酸时，这一片段可以被预测为α-helix 埋藏的β-sheet通常由连续的疏水残基组成，一侧暴露的β-sheet通常由亲水-疏水的两残基重复模式 第二代：基于立体化学原则的物理化学方法——Lim法 第三代：神经网络与人工智能 ** 运用了长程信息和蛋白质序列的进化信息** ","date":"2024-01-11","objectID":"/intro/:9:2","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"三级结构预测方法 同源建模法（homology modeling） 也称为比较建模法，是一种基于知识的蛋白质结构预测方法 根据对蛋白质结构数据库PDB中的蛋白质结构比较分析研究得知，任何一对蛋白质，只要它们序列的长度达到一定程度，序列相似性超过30%，就可以保证他们具有相似的三维结构 主要步骤：模版搜寻、序列比对、结构保守区寻找、目标模型搭建、结构优化和评估 折叠识别法（fold recognition） 蛋白质结构分类可以包括不同层次（ 折叠类型 、拓扑结构、家族、超家族、结构域、二级结构、超二级结构） 从头预测法（ab initio prediction） 从蛋白质的一级结构出发，根据物理化学、量子化学、量子物理的基本原理，利用各种理论方法计算蛋白质肽链所有可能构象的能量，然后从中找到能量最低的构象，作为蛋白质的天然构象 组成部分 表示蛋白质几何结构的方法 能量函数及其参数，或者一个合理的构象得分函数，以便计算各种构象的能量 构象空间搜索技术：对构象空间进行快速搜索，找到全局最小能量相对应的构象 ","date":"2024-01-11","objectID":"/intro/:9:3","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"膜蛋白 整合膜蛋白 （跨膜膜蛋白） 锚定蛋白 外周蛋白 ","date":"2024-01-11","objectID":"/intro/:9:4","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":[],"content":"糖基化修饰 先决条件：信号肽序列 特征： 20-35 AA 富含疏水氨基酸片段 至少含有一个带正电荷的氨基酸 糖苷键类型： O—糖苷键类型：丝氨酸、苏氨酸、羟赖氨酸、羟脯氨酸 N—糖苷键类型：天冬酰胺、赖氨酸、精氨酸 脂糖苷键：天冬氨酸、谷氨酸 糖肽键：半胱氨酸 训练预测蛋白质亚细胞定位的模型需要标注数据，数据来源于Swiss-prot 训练预测蛋白质三维结构的模型需要标注数据，数据来源于PDB 数据重复抽样方法 permutation test 无放回 bootstrap 有放回，且无法检验分子进化树的准确性 ","date":"2024-01-11","objectID":"/intro/:9:5","tags":[],"title":"生物信息原理复习","uri":"/intro/"},{"categories":["python"],"content":"python常用知识点复习 ","date":"2023-12-29","objectID":"/python/:0:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"数字与序列 ","date":"2023-12-29","objectID":"/python/:1:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"数据类型 数值类型： 整数 分数 浮点数 复数 布尔型 字符串 序列类型： 字符串 列表(list) 元组(tuple) 映射和集合类型： 字典(dict) 集合(set) 冻结集(frozenset) 数值类型 整数和分数 整数默认十进制，可以使用内建函数 bin oct hex将整数转换成二进制、八进制、十六进制的字符串 \u003e\u003e\u003e bin(5) #二进制 0-1 '0b101' \u003e\u003e\u003e oct(9) #八进制 0-7 '0o11' \u003e\u003e\u003e hex(23) #十六进制 0-9 a-f(A-F) '0x17' 分数 fractions标准库中Fraction类提供分数计算 \u003e\u003e\u003e from fractions import Fraction \u003e\u003e\u003e x = Fraction(2,5) \u003e\u003e\u003e y = Fraction(3,7) \u003e\u003e\u003e x+y Fraction(29, 35) \u003e\u003e\u003e x/y Fraction(14, 15) \u003e\u003e\u003e x**2 Fraction(4, 25) \u003e\u003e\u003e y.numerator #分子 3 \u003e\u003e\u003e y.denominator #分母 7 浮点数转换成分数 \u003e\u003e\u003e x = 2.3 \u003e\u003e\u003e x.as_integer_ratio() (2589569785738035, 1125899906842624) 整数型位运算 是对整数在二进制表示下的位进行的运算。主要有以下几种： 按位与（\u0026）：如果两个相应的二进制位都为1，则该位的结果值为1，否则为0。 按位或（|）：两个相应的二进制位中只要有一个为1，该位的结果值为1。 按位异或（^）：两个相应的二进制位值相同则为0，不同则为1。 按位取反（~）：对数据的每个二进制位取反,即把1变为0,把0变为1。 左移（«）：把«左边的数据的各二进制位全部左移若干位，右边空出的位用0填充。 右移（»）：把»左边的数据的各二进制位全部右移若干位，左边空出位用0的填充或者用符号位填充，具体情况取决于语言规定。 码值转换 chr(10) 数字编码转换成Unicode字符 ord(\"中\") 将Unicode字符转换成数字编码 布尔型 bool() 求布尔值 非零数字与非空集合布尔值都是 True 成员操作符 in 返回布尔值 布尔类型对象的三个操作符：and or not 浮点数与复数 浮点数64位，52位表示底，11为表示指数，剩下一位表示符号正负 复数为两个浮点数组成的有序数对，实部和虚部都是浮点数 访问实部、虚部、共轭复数、模 \u003e\u003e\u003e acomplex = 3+4j \u003e\u003e\u003e acomplex.real#实部 3.0 \u003e\u003e\u003e acomplex.imag#虚部 4.0 \u003e\u003e\u003e acomplex.conjugate \u003cbuilt-in method conjugate of complex object at 0x0000025F75FFA250\u003e \u003e\u003e\u003e acomplex.conjugate()#共轭复数 (3-4j) \u003e\u003e\u003e abs(acomplex) #求模 5.0 浮点数操作函数在math模块中，复数操作的函数在cmath模块中 \u003e\u003e\u003e import math \u003e\u003e\u003e import cmath \u003e\u003e\u003e from cmath import * 序列类型 任意类型的值作为元素(element)，按照一定顺序组合而成的数据结构 通用操作符 对象 [not] in 序列 seq[m:n] seq1 + seq2 seq1 * 3 重复操作 内建函数 len() min() max() sum() sort() zip() \u003e\u003e\u003e zip([1,2,3],['a','b','c']) \u003czip object at 0x000001E4E0533C80\u003e zip()函数返回的是一个迭代器，可以通过将其转换为列表来查看其内容 \u003e\u003e\u003e result = list(zip([1,2,3],['a','b','c'])) \u003e\u003e\u003e result [(1, 'a'), (2, 'b'), (3, 'c')] 将两个列表 [1,2,3]和 ['a','b','c']压缩成一个列表，其中每个元素都是一个元组 reversed() 倒序函数 enumerate()枚举函数 enumerate()函数将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标 \u003e\u003e\u003e for i, value in enumerate(['a', 'b', 'c']): ... print(i, value) ... 0 a 1 b 2 c 字符串 赋值 \u003e\u003e\u003e str1 = 'dasf' \u003e\u003e\u003e str2 = '1564 s' \u003e\u003e\u003e x = str1[0] \u003e\u003e\u003e x 'd' \u003e\u003e\u003e str1 + str2 #拼接 'dasf1564 s' \u003e\u003e\u003e str1 * 3 'dasfdasfdasf' \u003e\u003e\u003e str1[0] = 'd' #error 字符串内容不可修改 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: 'str' object does not support item assignment 操作 格式化输出字符串 \u003e\u003e\u003e print('The total is %0.2f' %56.432141) The total is 56.43 常见的格式说明符有以下几种： %s：字符串。使用str()将任何Python对象转换为字符串。 %d：整数。十进制整数。 %f：浮点数。默认保留6位小数，可以通过 .2f这样的形式控制小数位数。 %x：十六进制数。使用小写字母。 %X：十六进制数。使用大写字母。 %e：科学计数法表示的浮点数，使用小写的’e’。 %E：科学计数法表示的浮点数，使用大写的’E’。 %g：根据值的大小决定使用%f或%e。 %G：类似%g，但使用大写字母。 列表 列表（list）是一种有序的集合，可以随时添加和删除其中的元素 添加元素，append()末尾追加元素 insert()在指定位置插入元素 my_list.append('d') my_list.insert(1, 'inserted') #insert(插入索引位置， 插入元素) 合并列表,会修改原列表 list1 = [1, 2, 3] list2 = [4, 5, 6] list1.extend(list2) print(list1) # 输出：[1, 2, 3, 4, 5, 6] 删除元素，del pop() 或者 remove() del my_list[0] my_list.pop() my_list.remove('b') 列表切片访问 列表循环 列表推导式：简洁的方法创建列表 squares = [x**2 for x in range(10)] 列表排序 my_list.sort() new_list = sorted(my_list) 元组 元组（tuple）是一种有序的不可变序列，一旦创建就不能修改，是一种只读的数据结构 创建元组：使用圆括号 ()来创建元组，元素之间用逗号 ,分隔 创建只包含一个元素的元组，你需要在元素后面添加一个逗号 ,。这是因为括号 ()可以用于定义元组，也可以用于改变运算的优先级 访问元组元素：通过索引来访问元组中的元素，索引从0开始 不可变性：元组是不可变的，这意味着你不能在元组中添加、删除或修改元素 元组中的元素如果是可变的（如列表），那么你可以修改这个元素 \u003e\u003e\u003e h = (5, [1,5], ('saf', 45, 4)) \u003e\u003e\u003e h[1][1] = 6 \u003e\u003e\u003e h (5, [1, 6], ('saf', 45, 4)) 元组切片：可以使用切片来访问元组的一部分 可以使用for循环来遍历元组中的每一个元素 元组解包：如果你有一个包含多个元素的元组，你可以在一行中将这些元素赋值给多个变量 \u003e\u003e\u003e x,y,z = (1, 3, 53) \u003e\u003e\u003e x 1 \u003e\u003e\u003e y 3 \u003e\u003e\u003e z 53 元组和函数：元组经常用于Python函数的返回值，因为函数可以返回一个元组，从而一次返回多个值 def min_max(items): return min(items), max(items) print(min_max([1, 2, 3, 4, 5])) # 输出：(1, 5) 可哈希，可以作为字典的键key ","date":"2023-12-29","objectID":"/python/:1:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"练习 数学运算 运算符： // 向下取整 % 取模 使用cmath中的函数计算复数1+2j的正弦值（sin）和极坐标表示(polar) import cmath z = 1 + 2j sin_z = cmath.sin(z) print(f\"The sin of {z} is {sin_z}\") #极坐标转换表示 r,theta = cmath.polar(z) print (f\"The polar coordinates of {z} are (r={r}, theta={theta})\") print (f\"The polar coordinates of {z} are ({r:.2f},{theta:.2f})\") 在Python的格式化字符串（f-string）中，{r:.2f}表示将变量 r格式化为浮点数，并保留两位小数。 在 {r:.2f}中，:是格式说明符的开始，.2f是格式说明符，表示浮点数格式并保留两位小数 The sin of (1+2j) is (3.165778513216168+1.959601041421606j) The polar coordinates of (1+2j) are (r=2.23606797749979, theta=1.1071487177940904) The polar coordinates of (1+2j) are (2.24,1.11) 使用数学函数factorial计算70的阶乘 from math import factorial factorial(70) import math math.factorial(70) 字符串使用 列表使用 a_list = [1,2,3,4,5] alist = list(range(1,6)) blst = [1, 'a', 3.6, 2+5j] \u003e\u003e\u003e alist + blst [1, 2, 3, 4, 5, 1, 'a', 3.6, (2+5j)] \u003e\u003e\u003e blst * 3 [1, 'a', 3.6, (2+5j), 1, 'a', 3.6, (2+5j), 1, 'a', 3.6, (2+5j)] 列表模拟堆栈 堆栈，stack,后进先出 可以把堆栈想象成一摞盘子，新加入的盘子放在最上面，而移除盘子时也只能从最上面开始移除 alst = [1,2,3,4,5] #入栈 alst.append(6) #出栈 alst.pop(-1) 列表模拟队列 队列,queue,先进先出 可以把队列想象成一排等待付款的人，新来的人站在队伍的最后，而每次只有排在最前面的人可以离开 alst = [1,2,3,4,5] #入队 alst.append(6) #出队 alst.pop(0) #移除第一个元素，相当于队列开头元素 或者使用 collections模块中的 deque（双端队列）来实现队列 from collections import deque # 创建一个空队列 queue = deque() # 入队操作 queue.append('a') queue.append('b') queue.append('c') print(queue) # 输出：deque(['a', 'b', 'c']) # 出队操作 item = queue.popleft() print(item) # 输出：'a' print(queue) # 输出：deque(['b', 'c']) ","date":"2023-12-29","objectID":"/python/:1:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"流程控制、字典与集合 ","date":"2023-12-29","objectID":"/python/:2:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"条件语句 if...else if...elif...语句 布尔表达式 – 逻辑操作符 and or not ","date":"2023-12-29","objectID":"/python/:2:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"循环语句 while 循环 for 循环，遍历序列元素 ","date":"2023-12-29","objectID":"/python/:2:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"控制流程 continue 跳过循环剩余语句，继续下一轮循环 break 终止循环语句 pass 什么都不做 match-case (python 3.10,不做要求) ","date":"2023-12-29","objectID":"/python/:2:3","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"字典 赋值 a = {}; a = dict() #定义空字典 b = {'x':3, 'y':4} c = dict(uid=105, login='Lumberjack', name='Michael Palin') 操作 根据索引读取 u = c['uid'] 重定义 c['shell'] = '/bin/sh' 拷贝 Copy = c.copy() 清空字典 c.clear() 合并操作 |（py3.9 不做要求） ","date":"2023-12-29","objectID":"/python/:2:4","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"集合 赋值 定义可变集合 aset = {1,2,3} bset = set([2,5,8]) cset = set('anc') \u003e\u003e\u003e cset {'c', 'n', 'a'} 定义冻结结合，可哈希 dset = frozenset('abc') 操作 集合没有顺序索引 aset[0]这种操作不存在 1 in aset in 添加元素 aset.add(4) 去除元素 aset.remove(3) 集合交集 aset \u0026 bset \u0026 集合并集 aset | bset | 返回aset类型，aset为可变集合或者冻结集合 集合差集 aset - bset 在a不在b中的元素 集合对称差 aset ^ bset 两集合并集与交集的差集 ","date":"2023-12-29","objectID":"/python/:2:5","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"文件读写 文件对象，既可以是普通磁盘文件也可以是抽象文件：如内存区域、网页等 ","date":"2023-12-29","objectID":"/python/:3:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"文件对象 创建方法 file_object = open(file_name, access_mode = 'r', buffering = -1) access_mode: ‘r’ 读 ‘w’ 写 ‘a’ 追加 ‘+’ 可读可写 ‘b’ 二进制 buffering:访问文件的缓冲方式 0，不缓冲 1，缓冲一行 n,缓冲n行 负值，系统默认的缓冲模式 操作方法 #输入 read(size) readline(size) readlines() for eachline in file: print (eachline) #输出,写入文件 write(astr) writelines(str_list) ","date":"2023-12-29","objectID":"/python/:3:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"标准文件 import sys sys模块提供了对一些用于与Python解释器交互的变量和函数的访问 sys.argv：这是一个列表，包含了从命令行传递给Python脚本的参数。sys.argv[0]是脚本的名称。 sys.exit()：这个函数可以使你的脚本退出，可选地向调用者返回一个状态码。 sys.path：这是一个字符串列表，包含了Python解释器查找模块的路径。你可以修改这个列表来影响模块的查找和加载。 sys.stdin、sys.stdout和 sys.stderr：这些是标准的输入、输出和错误流的文件对象。你可以重定向这些流，或者向它们写入或读取数据。 sys.getsizeof(object)：返回对象的大小（以字节为单位）。 sys.version：这是一个字符串，包含了当前Python解释器的版本信息。 ","date":"2023-12-29","objectID":"/python/:3:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"文件系统访问 import os ","date":"2023-12-29","objectID":"/python/:3:3","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"练习：统计DNA核苷酸频率 A_num = C_num = G_num = T_num = 0 for i in range(len(DNAstr)): if DNAstr[i]=='A': A_num = A_num + 1 elif DNAstr[i]=='C': C_num = C_num + 1 elif DNAstr[i]=='G': G_num += 1 #another way elif DNAstr[i]=='T': T_num += 1 #another way print(\"A_num =\", A_num) print(\"C_num =\", C_num) print(\"G_num =\", G_num) print(\"T_num =\", T_num) total_num = len(DNAstr) print(\"A_frq =\", A_num/total_num) print(\"C_frq =\", C_num/total_num) print(\"G_frq =\", G_num/total_num) print(\"T_frq =\", T_num/total_num) dna_dic = {'A': 0, 'C': 0, 'G': 0, 'T': 0} #the dict for DNA numbers for n in DNAstr: dna_dic[n] += 1 print(dna_dic) #print out the DNA numbers in a dict format dna_frq_dic = {} DNAs = 'ACGT' #the 4 kinds of nucleiotides for d in DNAs: #calculate the frequencies dna_frq_dic[d] = dna_dic[d]/total_num print(dna_frq_dic) #print out the DNA frequencies in a dict format output_file_name = 'D:/frq.txt' output_file = open(output_file_name, 'wt') #open file in a writing and text model output_string = '\\t'.join(DNAs) output_file.write(output_string + '\\n') output_string = '' for d in DNAs: output_string += str(dna_dic[d]) + '\\t' output_string = output_string.strip() output_string += '\\n' output_file.write(output_string) olst = [] #create a list for DNA frequencies for d in DNAs: olst.append(str(dna_frq_dic[d])) output_string = '\\t'.join(olst) + '\\n' output_file.write(output_string) output_file.close() #please check the file D:\\frq.txt to see what you got ","date":"2023-12-29","objectID":"/python/:3:4","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"with语句读取DNA序列 with语句和文件上下文管理器（file context manager）读写文件 f-string格式化浮点数（频率）输出 #This is a demo script for \"with\" and \"file\" context manager. with open('DNAseq.txt','rt') as ifl: DNAstr = ifl.read() DNAlen = len(DNAstr) - 1 A_frq = DNAstr.count('A')/DNAlen C_frq = DNAstr.count('C')/DNAlen G_frq = DNAstr.count('G')/DNAlen T_frq = DNAstr.count('T')/DNAlen print('A_frq =', A_frq) print('C_frq =', C_frq) print('G_frq =', G_frq) print('T_frq =', T_frq) with open('DNAfrq.txt', 'wt') as ofl: ofl.write('\\t'.join(['A', 'C', 'G', 'T'])+'\\n') #using f-string to format output ofl.write(f'{A_frq: .3f}\\t{C_frq: .3f}\\t{G_frq: .3f}\\t{T_frq: .3f}\\n' ","date":"2023-12-29","objectID":"/python/:3:5","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"文件操作 序列每十个字符放在一行输出至文件中 def write_sequence_to_file(sequence, file_path): with open(file_path, 'w') as f: for i in range(0, len(sequence), 10): f.write(sequence[i:i+10] + '\\n') 将生成文件每行拆分成一个文件，以数字命名 def split_file_into_parts(file_path, output_directory): with open(file_path, 'r') as f: for i, line in enumerate(f, start=1): new_file_path = f\"{output_directory}\\\\{i}.txt\" with open(new_file_path, 'w') as new_file: new_file.write(line)p 将拆分的文件合并 import os def merge_files(input_directory, output_file_path): with open(output_file_path, 'w') as output_file: for filename in sorted(os.listdir(input_directory), key=lambda x: int(x.split('.')[0])): file_path = os.path.join(input_directory, filename) with open(file_path, 'r') as input_file: output_file.write(input_file.read()) ","date":"2023-12-29","objectID":"/python/:3:6","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"函数定义 定义函数，读取fasta文件至列表中： def readIntoList(filename): ifl=open(filename,'rt') iflst=ifl.readlines() ifl.close() iflstlen=len(iflst) seqlist=[] aseq = [] titstr = '' seqstr='' for i in iflst: i = i.strip() if i[0]=='\u003e': titstr = i if seqstr!='': aseq.append(pretitstr) aseq.append(seqstr) seqlist.append(aseq) seqstr = '' aseq = [] else: seqstr += i pretitstr = titstr aseq = [titstr, seqstr] seqlist.append(aseq) return seqlist faflname = 'Seqs.fasta' seqlst = readIntoList(faflname) for s in seqlst: print(s[0][:15], s[1][:15]) ","date":"2023-12-29","objectID":"/python/:4:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"函数参数 def get_sum(a, b=2, *theRestTuple, **theRestDict): print('Sum is', a+b+sum(theRestTuple)+sum(theRestDict.values()) ) 调用：get_sum(1,2,3,4,c=5,d=6) *args和 **kwargs是两种特殊的参数，它们允许你在定义函数时接收任意数量的位置参数和关键字参数。 *args用于收集传递给函数的位置参数，这些参数被打包成一个元组。 **kwargs用于收集传递给函数的关键字参数，这些参数被打包成一个字典。 #变长参数组（元组或字典）： #非关键字参数（元组）： def get_sum(a, b=2, *theRest): print('The sum is ', a + b + sum(theRest) ) #调用：\u003e\u003e\u003e get_sum(1,2,3,4) #关键字参数（字典）： def get_sum(a, b=2, **theRest): print('The sum is ', a+b+sum(theRest.values()) ) 调用：get_sum(1,2,c=3,d=4) 逆向使用：在函数调用时,*和 **操作符也可以在函数调用时使用，用于解包序列和字典。 *操作符可以用于解包序列（如列表或元组），**操作符可以用于解包字典。 ","date":"2023-12-29","objectID":"/python/:4:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"面对对象编程(OOP) 一切皆对象，每个对象有属性（数据）、方法（行为） 三个核心概念：封装、继承、多态 封装：封装是将对象的状态（属性）和行为（方法）包装在一起的过程。这可以隐藏对象的内部实现细节，并防止外部代码直接访问对象的内部数据。 继承：继承是一种使得一个类（子类）可以使用另一个类（父类）的属性和方法的机制。子类可以继承父类的属性和方法，也可以添加新的属性和方法，或者覆盖父类的属性和方法。 多态：多态是指允许一个接口（父类或者接口）有多种实现形式（子类的实现）。在运行时，可以根据实际类型来执行相应的方法，这使得我们可以在设计更高层的代码时，只需要关心接口而不是具体的类。 ","date":"2023-12-29","objectID":"/python/:5:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"类定义、封装与组合 定义 类定义需要指定构造方法 init() class Dog: def __init__(self): self.mouth = \"big\" def bark(self): print(\"Woof!\") 执行 wangcai =Dog() 时实际上是执行了 Dog.init(wangcai) 这个方法(函数) 无法通过类名直接调用实例方法,如 Dog.bark() 错误的 \u003e\u003e\u003e wangcai = Dog() \u003e\u003e\u003e wangcai.bark() Woof! \u003e\u003e\u003e Dog.bark() Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: Dog.bark() missing 1 required positional argument: 'self' \u003e\u003e\u003e Dog.bark(wangcai)#传递一个实例作为参数 Woof! 类定义中可选定义 析构方法,当一个对象即将被系统回收时，__del__()方法会被自动调用 class Dog: def __init__(self): self.mouth = \"big\" def bark(self): print(\"Woof!\") def __del__(self): print(\"A dog object has been deleted.\") 当 Dog类的一个实例被删除时，__del__()方法会被调用，输出：“A dog object has been deleted.” 练习 \u003e\u003e\u003e print(Dog.mouth) Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e AttributeError: type object 'Dog' has no attribute 'mouth' \u003e\u003e\u003e print(wangcai.mouth) big \u003e\u003e\u003e print(Dog.bark) \u003cfunction Dog.bark at 0x000002644983EE60\u003e \u003e\u003e\u003e print(wangcai.bark) \u003cbound method Dog.bark of \u003c__main__.Dog object at 0x000002644981B130\u003e\u003e print(Dog.mouth)：试图访问类 Dog的属性 mouth，但是 mouth是定义在 Dog类的实例上的，而不是类本身，所以会报 AttributeError。 print(wangcai.mouth)：访问的是 Dog类的一个实例 wangcai的 mouth属性，这是正确的。 print(Dog.bark)：访问的是类 Dog的方法 bark，它返回的是一个函数对象，所以你看到的是一个函数的内存地址。 print(wangcai.bark)：访问的是 Dog类的一个实例 wangcai的 bark方法，它返回的是一个绑定方法对象，这个方法已经绑定到了实例 wangcai上。 类的属性 访问一个属性时，Python首先会在实例的属性中查找，如果找不到，就会去类的属性中查找 class Dog: jaw = [\"sharp\", 32] paw = [\"cute\", 4] def __init__(self): self.mouth = \"big\" print(Dog.jaw) xiaobai = Dog() print(xiaobai.paw) 特殊属性和方法 Dog.__doc__:类的文档字符串 Dog.__dict__: 类的所有属性 Dog.__module__: 类所在模块 Dog.__class__: 所属的类型 xiaohei.__sizeof__(): 对象内存大小 实例方法 \u003e\u003e\u003e print(Dog.__doc__) None \u003e\u003e\u003e print(Dog.__class__) \u003cclass 'type'\u003e \u003e\u003e\u003e print(Dog.__dict__) {'__module__': '__main__', 'jaw': ['sharp', 32], 'paw': ['cute', 4], '__init__': \u003cfunction Dog.__init__ at 0x000002644983F010\u003e, '__dict__': \u003cattribute '__dict__' of 'Dog' objects\u003e, '__weakref__': \u003cattribute '__weakref__' of 'Dog' objects\u003e, '__doc__': None} 类的方法 方法定义中不用self 可以通过类直接调用，也可以通过实例调用 静态方法 在Python中，静态方法是一种特殊的方法，可以使用 @staticmethod装饰器或 staticmethod()函数将一个方法定义为静态方法 class example: def foo(): print(\"This is a static method.\") foo = staticmethod(foo) class example: @staticmethod def foo(): print(\"This is a static method.\"） 类方法 classmethod() 函数修饰符@ @staticmethod @classmethod 如上 型与类 class Dog: head = 1 tail = 3 @classmethod def show_head(cls): print('The head is ', cls.head) #show_head = classmethod(show_head) @staticmethod def show_tail(): print('The tail is', Dog.tail) #show_tail = staticmethod(show_tail) def __init__(self): self.jaw = 'strong' def show_jaw(self): print('The jaw is', self.jaw) def show_head_2(self): print('The head is', Dog.head) @classmethod def show_jaw_2(cls): print('The jaw is', self.jaw) @staticmethod def show_jaw_3(): print('The jaw is', self.jaw) Dog.show_head() Dog.show_tail() Dog.show_jaw() Dog.show_jaw_2() Dog.show_jaw_3() adog = Dog() adog.show_head() adog.show_head_2() adog.show_tail() adog.show_jaw() ","date":"2023-12-29","objectID":"/python/:5:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"继承、多态 继承 定义子类 super()函数是用来调用父类（超类）的一个方法，即可以在不关心对象具体类型的情况下编写代码，只需要关心对象是否有你需要的方法或属性 class Parent: def __init__(self, name): self.name = name def say_hello(self): print(f\"Hello, I'm {self.name}\") class Child(Parent): def say_goodbye(self): print(f\"Goodbye, I'm {self.name}\") # 创建一个Child对象 child = Child(\"Tom\") # 调用从Parent类继承的say_hello方法 child.say_hello() # 调用Child类自己的say_goodbye方法 child.say_goodbye() 多态 多态是指不同的对象可以响应相同的方法调用 Python中，可以在两个不相干的类中定义同样的方法接口，从而实现多态 Ø定义分子类（Molecule）作为基类，包含集合elements和weight作为其属性，用初始化函数，将elements初始化为空集，weight初始化为None；定义show_weight方法，该方法用print函数打印输出分子量weight；定义show_elements方法，用print函数打印输出元素集合。 Ø定义AminoAcid类，继承Molecule类，包含composition属性，并初始化为下面的元素字典：{‘C’: 0, ‘H’: 0, ‘O’: 0, ‘N’: 0, ‘S’: 0}；定义calc_mw方法，根据根据字典的元素组成，计算其分子量（需要用到每种原子的质量，自己去查），并给继承自父类的weight属性赋值；重载show_weight方法，在其中调用calc_mw方法，计算氨基酸的分子量，再调用父类的show_weight方法，打印输出weight值；重载show_elements方法，用元素字典中的非零值的键生成元素集合，再打印输出元素集合。 Ø分别定义亮氨酸（Leucine）、异亮氨酸（Isoleucine）、半胱氨酸（Cysteine）类，均继承自AminoAcid类，在初始化方法中，根据这三种氨基酸的元素组成（这个要自己去查），为其继承来的元素字典的各元素对应赋值；定义show_composition方法，打印输出氨基酸的元素字典；在Leucine类中定义is_isoform方法，接受一个氨基酸对象作为参数，根据氨基酸的元素组成，判断是否为当前氨基酸的同分异构体，返回布尔值（True或者False）。 Ø分别生成Leucine、Isoleucine、Cysteine类的实例leu、iso、cys，通过该实例，调用其show_weight、show_elements、show_composition等方法，查看当前氨基酸的分子量、元素集合、元素字典；通过leu，调用其is_isoform方法，分别以实例iso和cys为参数，查看各自的返回值，以判定是否同分异构体。 # class Molecule: def __init__(self): self.elements = set() self.weight = None def show_weight(self): print(self.weight) def show_elements(self): print(self.elements) class AminoAcid(Molecule): def __init__(self): super().__init__() self.composition = {'C': 0, 'H': 0, 'O': 0, 'N': 0, 'S': 0} def calc_mw(self): self.weight = self.composition['C']*12.01 + self.composition['H']*1.008 + self.composition['O']*16.00 + self.composition['N']*14.01 + self.composition['S']*32.07 def show_weight(self): self.calc_mw() super().show_weight() def show_elements(self): self.elements = {k for k, v in self.composition.items() if v != 0} super().show_elements() class Leucine(AminoAcid): def __init__(self): super().__init__() self.composition = {'C': 6, 'H': 13, 'O': 1, 'N': 1, 'S': 0} def show_composition(self): print(self.composition) def is_isoform(self, other): return self.composition == other.composition class Isoleucine(AminoAcid): def __init__(self): super().__init__() self.composition = {'C': 6, 'H': 13, 'O': 1, 'N': 1, 'S': 0} def show_composition(self): print(\"Isoleucine composition: \", self.composition) class Cysteine(AminoAcid): def __init__(self): super().__init__() self.composition = {'C': 3, 'H': 7, 'O': 2, 'N': 1, 'S': 1} def show_composition(self): print(\"Cysteine composition: \", self.composition) leu = Leucine() iso = Isoleucine() cys = Cysteine() print(\"Leucine weight: \") leu.show_weight() print(\"Leucine elements: \") leu.show_elements() print(\"Leucine composition: \") leu.show_composition() print(\"Is Isoleucine an isoform of Leucine? \", leu.is_isoform(iso)) print(\"Is Cysteine an isoform of Leucine? \", leu.is_isoform(cys)) print(\"Isoleucine weight: \") iso.show_weight() print(\"Isoleucine elements: \") iso.show_elements() print(\"Isoleucine composition: \") iso.show_composition() print(\"Cysteine weight: \") cys.show_weight() print(\"Cysteine elements: \") cys.show_elements() print(\"Cysteine composition: \") cys.show_composition() ","date":"2023-12-29","objectID":"/python/:5:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"动态语法、异常处理 ","date":"2023-12-29","objectID":"/python/:6:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"求值函数eval() eval(\"{}.fromkeys(range(2))\")：计算表达式 {}.fromkeys(range(2))，输出结果为 {0: None, 1: None}，这是一个字典，它的键是 range(2)生成的数字，值都是 None。 eval(\"list(map(lambda x: x**2, range(3)))\")：计算表达式 list(map(lambda x: x**2, range(3)))，输出结果为 [0, 1, 4]，这是一个列表，它的元素是 range(3)生成的数字的平方。 eval(\"[pow(i,0.5) for i in range(3)]\")：计算表达式 [pow(i,0.5) for i in range(3)]，输出结果为 [0.0, 1.0, 1.4142135623730951]，这是一个列表，它的元素是 range(3)生成的数字的平方根。 eval(\"(abs(x) for x in [-1,2,-3,4])\").__next__()：计算表达式 (abs(x) for x in [-1,2,-3,4])，这是一个生成器，它的元素是列表 [-1,2,-3,4]的元素的绝对值。__next__()方法获取生成器的下一个元素，输出结果为1。 astr = \"x**y\"; a_scope = {'x': 3, 'y': 4}; eval(astr, a_scope)：计算表达式 x**y，在这个表达式中，x和 y的值是在 a_scope字典中定义的。输出结果为81，这是3的4次方。 ","date":"2023-12-29","objectID":"/python/:6:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"执行函数exec() exec(source, [globals, [locals]])函数可以执行以字符串形式或代码对象给定的Python语句，表达式需要是语句 \u003e\u003e\u003e exec(\"print({}.fromkeys(range(2)))\") #输出{0: None, 1: None} \u003e\u003e\u003e exec(\"f = lambda x: x**2\"); f(3) 9 \u003e\u003e\u003e exec(\"def func(x): return x**2\"); func(3) 9 \u003e\u003e\u003e astr = \"print(x**y)\" \u003e\u003e\u003e a_scope = {'x': 3, 'y': 4} \u003e\u003e\u003e exec(astr, a_scope) 81 ","date":"2023-12-29","objectID":"/python/:6:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"动态代码生成（表达式） \u003e\u003e\u003e from math import sin \u003e\u003e\u003e funstr = '' \u003e\u003e\u003e for i in range(1,100): funstr += 'sin(' + str(i) + '*x)' + '+' \u003e\u003e\u003e funstr = funstr.rstrip('+') \u003e\u003e\u003e f_val_lst = map(lambda x: eval(funstr), range(100)) \u003e\u003e\u003e sum(f_val_lst) 126.6596615979565 \u003e\u003e\u003e from math import sin \u003e\u003e\u003e funlst = [] #函数列表 \u003e\u003e\u003e for i in range(1,100): exec('def sin_'+str(i)+'(x): return sin('+str(i)+'*x)') #定义函数 funlst.append(eval('sin_'+str(i))) #把函数名添加为列表元素 \u003e\u003e\u003e dir() #查看名字空间，看是否存在sin_i形式的函数名 \u003e\u003e\u003e funlst[0] #查看函数列表的第一个元素，看是否是sin_1 \u003cfunction sin_1 at 0x000000000339BCF8\u003e \u003e\u003e\u003e f_val_lst = [sum(map(lambda y: y(i), funlst)) for i in range(100)] \u003e\u003e\u003e sum(f_val_lst) 126.6596615979565 ","date":"2023-12-29","objectID":"/python/:6:3","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"代码对象 compile(source, filename, mode, […]) source：要编译的源代码。它可以是一个字符串，也可以是一个AST对象。 filename：源代码的文件名。如果源代码没有来自文件，你可以传递一些可以识别源代码的字符串。 mode：指定编译代码的模式。它必须是 'exec'、'eval'或 'single'之一。需要搭配 eval() exec()函数使用 'exec'：如果源代码由一系列语句组成，python模块或者文件 'eval'：源代码由一个表达式组成 'single'：源代码由单个交互式语句组成 \u003e\u003e\u003e eval_code = compile( '3+4', '', 'eval') #可求值表达式 \u003e\u003e\u003e eval_code \u003ccode object \u003cmodule\u003e at 0000000002C59630, file \"\", line 1\u003e \u003e\u003e\u003e eval(eval_code) 7 \u003e\u003e\u003e callable(eval_code) #code对象可执行，但不可调用 False \u003e\u003e\u003e single_code = compile(\"print('hello world!')\",'','single') \u003e\u003e\u003e exec(single_code) hello world! \u003e\u003e\u003e exec_code = compile('', '', 'exec') #三引号（'''或\"\"\"）定义多行字符 \u003e\u003e\u003e exec_code = compile('''n = input('Count how many numbers?') for i in range(int(n)): print(i) ''', '', 'exec') \u003e\u003e\u003e exec(exec_code) Count how many numbers?5 0 1 2 3 4 ","date":"2023-12-29","objectID":"/python/:6:4","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"异常处理 异常是一个事件，表示在程序执行过程中发生了错误。当Python解释器遇到错误时，它会引发一个异常。如果这个异常没有被捕获和处理，程序就会终止。 可以使用 try/except语句来捕获和处理异常。try块包含可能引发异常的代码，except块包含处理异常的代码。例如： try: x = 1 / 0 # 这将引发一个ZeroDivisionError except ZeroDivisionError: print(\"You can't divide by zero!\") 可以使用 raise语句来引发一个异常。可以引发一个内置的异常，也可以定义一个新的异常类并引发它 class MyException(Exception): pass try: raise MyException(\"This is a custom exception\") except MyException as e: print(e) MyException是一个新的异常类，它继承自内置的 Exception类。raise语句引发了一个 MyException实例，然后 except块捕获了这个异常并打印了它的消息。 #You may copy this line into the console. ProSeq = 'MNAPERQPQPDGBBGDAPGHEPGGSPQDELDFSILFDYEYLNPNEEEPNAHKVASPPSOOGPAYPDDVLDYGLKPYSPLASLSGEPPGRFGEPDBRVGPQKFLSAAKPAGASGLSPRIEITPSHELIQAVGPLRMRDAGLLVEQPPLAGVAASPRFTLPVPGFEGYREPLCLSPAXSSGSSASFISDTFSPYTSPCVSPNNGGPUDDLCPQFQNIPAHYSPRTSPIMSPRTSLAEDSCLGRHSPVPRPASRSSSPGAXXXKRRHSCAEALVALPPGASPQRSRSPSPQPSSHVAPQDHGSPAGYPPVAGSAVIMDALNSLATDXSPCGIPPKMWKTXSP' #The 20 normal amino acids AA20 = 'ACDEFGHIKLMNPQRSTVWY' #### The dict for amino acid numbers #### aa_dic = {} for a in AA20: aa_dic[a] = 0 #### The try-except clauses #### for a in ProSeq: try: aa_dic[a] += 1 except KeyError: # or # except: print('Find an abnormal amino acid:', a) print(aa_dic) ","date":"2023-12-29","objectID":"/python/:6:5","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"泛函编程、迭代器、生成器 ","date":"2023-12-29","objectID":"/python/:7:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"泛函编程 泛函编程是一种编程范式，强调使用函数和避免改变状态。在Python中，你可以使用高阶函数（如 map()、filter()和 reduce()），以及lambda函数来进行泛函编程。例如： # 使用map和lambda函数来对列表中的每个元素加1 nums = [1, 2, 3, 4, 5] nums_plus_one = map(lambda x: x + 1, nums) print(list(nums_plus_one)) # 输出 [2, 3, 4, 5, 6] ","date":"2023-12-29","objectID":"/python/:7:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"迭代器、生成器 迭代器 ：迭代器是一个可以记住遍历的位置的对象。迭代器对象必须实现两个方法，__iter__()和 __next__()。 class TestIterator: value = 0 def __next__(self): self.value += 1 if self.value \u003e 10: raise StopIteration return self.value def __iter__(self): return self ti = TestIterator() list(ti)#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 可以使用 next()函数来获取迭代器的下一个元素。例如： __next__() \u003e\u003e\u003e a = eval(\"(abs(x) for x in [-1,2,-3,4])\") \u003e\u003e\u003e a.__next__() 1 \u003e\u003e\u003e a.__next__() 2 生成器 ：生成器是一种特殊的迭代器，可以使用 yield语句来生成值。生成器是一种惰性计算的方式，只有在需要下一个值时才会计算。 \u003e\u003e\u003e nested = [[1,2], [3,4], [5]] \u003e\u003e\u003e def flatten(nested): for sublist in nested: for element in sublist: yield element #print(element) \u003e\u003e\u003e for num in flatten(nested): #逐行输出各个数字 print(num) \u003e\u003e\u003e list(flatten(nested)) #返回数字列表 [1, 2, 3, 4, 5] ","date":"2023-12-29","objectID":"/python/:7:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"模块与程序库 在Python中，模块和包是用来组织代码的两种主要方式。 模块 模块是一个包含Python代码的.py文件。你可以在一个模块中定义函数、类和变量，然后在其他模块中使用 import语句来导入这个模块，使用这些函数、类和变量。例如，如果你有一个名为 mymodule.py的文件，你可以使用 import mymodule来导入这个模块。 包 包是一个包含多个模块的目录，这个目录必须包含一个 __init__.py文件（在Python 3.3及以后的版本中，这个文件可以为空）。你可以使用 .来导入包中的模块。例如，如果你有一个名为 mypackage的包，这个包中有一个名为 mymodule的模块，你可以使用 import mypackage.mymodule来导入这个模块。 __init__.py文件中的内容，主要是定义一些全局对象（包括变量、函数、类等），检测系统的运行环境，包括操作系统环境和Python安装程序的版本等信息。 __init__.py文件在包被第一次导入时，会被编译成.pyc文件；之后，若无改动，则不再编译 使用模块和包可以帮助你组织代码，使代码更易于理解和维护 可以将相关的代码放在同一个模块中，将相关的模块放在同一个包中。 ","date":"2023-12-29","objectID":"/python/:8:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"模块 模块的搜索路径可以通过sys.path列表进行查看和修改 \u003e\u003e\u003e import sys \u003e\u003e\u003e print(sys.path) ['', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx\\\\python310.zip', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx\\\\DLLs', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx\\\\lib', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx\\\\lib\\\\site-packages', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx\\\\lib\\\\site-packages\\\\win32', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx\\\\lib\\\\site-packages\\\\win32\\\\lib', 'E:\\\\coding\\\\Miniforge3\\\\envs\\\\dzx\\\\lib\\\\site-packages\\\\Pythonwin'] 可以使用 sys.path.append(\"path\")增加模块的搜索路径 ","date":"2023-12-29","objectID":"/python/:8:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"包 package 程序包，简称“包”，是以文件系统的目录形式组织的模块的集合。模块文件所在的目录就是包，前提是包含初始化文件，即名为 __init__.py的文件。 ","date":"2023-12-29","objectID":"/python/:8:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"程序包分类 Python自带的程序包，也叫标准库（Standard Library），在Python的安装目录下，模块文件分于libs、Lib目录及其子目录中。 第三方写的程序包，即，别人写的、用户可以拿来用的程序包，一般存放在：Python安装目录/Lib/site-packages目录下。 用户自己写的程序包，一般放在当前目录下，或用户目录下，或其他搜索路径可以找到的目录下，比如，Python安装目录/Lib/site-packages目录下。 ","date":"2023-12-29","objectID":"/python/:8:3","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"练习 time模块 random模块 ","date":"2023-12-29","objectID":"/python/:8:4","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"正则表达式 re模块提供了正则表达式匹配操作，正则表达式是一种强大的字符串处理工具，可以用来进行字符串的匹配、替换和分割等操作。 以下是 re模块的一些主要函数： re.match(pattern, string)：从字符串的开始位置匹配模式，如果在开始位置匹配成功，返回一个匹配对象，否则返回None。 re.search(pattern, string)：搜索整个字符串，找到第一个匹配的位置，返回一个匹配对象，如果没有找到匹配，返回None。 re.findall(pattern, string)：返回一个列表，包含字符串中所有匹配的子串。 re.sub(pattern, repl, string)：将字符串中匹配模式的部分替换为repl，返回替换后的字符串。 import re # 匹配字符串中的数字 result = re.findall(r'\\d+', 'hello 123 world 456') print(result) # 输出 ['123', '456'] # 替换字符串中的数字为'num' result = re.sub(r'\\d+', 'num', 'hello 123 world 456') print(result) # 输出 'hello num world num' from re import * some_text = \"alpha.beta....gamma delta\" pat = compile('.a') match(pat, some_text) \u003e\u003e\u003e print(match(pat, some_text)) None \u003e\u003e\u003e result = search(pat, some_text) \u003e\u003e\u003e print(result) \u003cre.Match object; span=(3, 5), match='ha'\u003e \u003e\u003e\u003e result.group() 'ha' \u003e\u003e\u003e split(compile('a.'), some_text) ['', 'ph', 'bet', '...g', 'm', 'delta'] \u003e\u003e\u003e split(compile('a .'), some_text) ['alpha.beta....gamm', 'elta'] \u003e\u003e\u003e sub(pat, 'b', some_text) 'alpb.beb....bmb delb' ","date":"2023-12-29","objectID":"/python/:9:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"模式匹配符 .：匹配任何字符（除了换行符）。 ^：匹配字符串的开始。 $：匹配字符串的结束。 *：匹配前面的子表达式零次或多次。 +：匹配前面的子表达式一次或多次。 ?：匹配前面的子表达式零次或一次。 {n}：匹配前面的子表达式n次。 {n,}：匹配前面的子表达式n次或更多次。 {n,m}：匹配前面的子表达式至少n次，但不超过m次。 ","date":"2023-12-29","objectID":"/python/:9:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"类别匹配符 \\d：匹配任何数字，等价于 [0-9]。 \\D：匹配任何非数字字符，等价于 [^0-9]。 \\s：匹配任何空白字符，等价于 [\\t\\n\\r\\f\\v]。 \\S：匹配任何非空白字符，等价于 [^\\t\\n\\r\\f\\v]。 \\w：匹配任何字母数字字符，等价于 [a-zA-Z0-9_]。 \\W：匹配任何非字母数字字符，等价于 [^a-zA-Z0-9_]。 ","date":"2023-12-29","objectID":"/python/:9:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"Biopython使用实例 ","date":"2023-12-29","objectID":"/python/:10:0","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"Bio.Seq模块 #从Biopython中引入序列类 from Bio.Seq import Seq #生成一个含有A、C、G、T的字符串 astr = 'ATGAAACGCATTAGCACCACCATTACCACCACCATCACCATTACCACAGGTAACGGTGCGGGCTGA' #生成一条DNA序列，即，Seq类的一个实例 dna_seq = Seq(astr) #查看序列对象 dna_seq print(dna_seq) #查看DNA序列的第一个字符、最后一个字符、前10个字符 dna_seq[0] dna_seq[-1] print(dna_seq[:10]) #把DNA序列当成普通字符串，用循环依次输出其字符 for a in dna_seq: print(a) #查看DNA序列对象的属性和方法 dir(dna_seq) #计算DNA序列中G的含量 G_num = dna_seq.count('G') print('G content is :', G_num/len(dna_seq)) #得到DNA序列的互补序列 c_dna_seq = dna_seq.complement() c_dna_seq #得到DNA序列的反向互补序列 rc_dna_seq = dna_seq.reverse_complement() rc_dna_seq #调用转录方法，得到RNA序列 rna_seq = dna_seq.transcribe() rna_seq #调用翻译方法，得到Protein序列 pro_seq = dna_seq.translate() pro_seq #计算蛋白序列中氨基酸T出现的次数 pro_seq.count('T') #查看蛋白序列对象的属性和方法 dir(pro_seq) ","date":"2023-12-29","objectID":"/python/:10:1","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["python"],"content":"PDB模块 from Bio.PDB import * #查看当前环境中定义了哪些变量、函数和类 dir() pdbflname = 'pdb4xb7.ent' #调用PDBParser()类，创建一个PDBParser对象，解析PDB文件 parser = PDBParser() struct = parser.get_structure('s1', pdbflname) for model in struct.get_iterator(): for chain in model.get_iterator(): for chain in model.get_iterator(): for residue in chain.get_iterator(): for atom in residue.get_iterator(): print(atom) atomcord = [0, 0, 0]; atomnum = 0 for model in struct.get_iterator(): for chain in model.get_iterator(): for chain in model.get_iterator(): for residue in chain.get_iterator(): for atom in residue.get_iterator(): atomcord[0] += atom.get_coord()[0] atomcord[1] += atom.get_coord()[1] atomcord[2] += atom.get_coord()[2] atomnum += 1 geomcenter = (atomcord[0]/atomnum, atomcord[1]/atomnum, atomcord[2]/atomnum) print('geometric center is:', geomcenter) ","date":"2023-12-29","objectID":"/python/:10:2","tags":[],"title":"python基础知识复习","uri":"/python/"},{"categories":["Azure VPS"],"content":"安装Docker和Nginx Proxy Manager ","date":"2023-12-27","objectID":"/vaultwarden/:1:0","tags":[],"title":"密码管理器vaultwarden","uri":"/vaultwarden/"},{"categories":["Azure VPS"],"content":"添加swap虚拟内存 VPS 的内存如果过小，建议设置一下 SWAP，一般为内存的 1-1.5 倍即可，可以让系统运行更流畅！ wget -O box.sh https://raw.githubusercontent.com/BlueSkyXN/SKY-BOX/main/box.sh \u0026\u0026 chmod +x box.sh \u0026\u0026 clear \u0026\u0026 ./box.sh 1. wget -O box.sh https://raw.githubusercontent.com/BlueSkyXN/SKY-BOX/main/box.sh： 使用wget工具从给定的URL下载一个文件，并将其保存为box.sh。-O box.sh参数指定了输出文件的名称。 2. chmod +x box.sh：这个命令改变了box.sh文件的权限，使其变为可执行。+x表示添加执行（x）权限。 3. clear：清空终端的屏幕 4. ./box.sh：这个命令执行了box.sh脚本。./表示当前目录，所以./box.sh就是执行当前目录下的box.sh文件。 5. 使用\u0026\u0026连接，当且仅当前一个命令成功执行后才执行后面的命令 输入数字18，选择设置SWAP 设置swap数值，并使用 free -h查看内存设置情况 ","date":"2023-12-27","objectID":"/vaultwarden/:1:1","tags":[],"title":"密码管理器vaultwarden","uri":"/vaultwarden/"},{"categories":["Azure VPS"],"content":"升级packages 因为密码管理器是我新服务器下第一个项目，先升级安装常用的软件 sudo -i #切换至root用户 Debian或者Ubuntu都是基于Debian的linux发行版，常用apt作为包管理器 apt update -y apt install wget curl sudo vim git -y 我因为手边有一本鸟叔的Linux工具书，选择了和书中一致的CentOS,应该使用yum或者dnf作为包管理器 yum update -y yum install wget curl sudo vim git -y ","date":"2023-12-27","objectID":"/vaultwarden/:1:2","tags":[],"title":"密码管理器vaultwarden","uri":"/vaultwarden/"},{"categories":["Azure VPS"],"content":"安装Docker环境 安装Docker (境外VPS) wget -qO- get.docker.com | bash -q 下载过程中静默下载，不输出下载信息 -O- 下载内容输出值stdout,直接给后面bash命令执行 docker -v #查看docker版本，判断是否安装成功 systemctl enable docker #设置成开机自启动 安装docker-compose Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：https://github.com/docker/compose/releases 运行以下命令以下载 Docker Compose 的当前稳定版本：(尝试v2.2.2没有报错，最新版v2.4报错) sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 将可执行权限应用于二进制文件： sudo chmod +x /usr/local/bin/docker-compose 创建软链：（/usr/bin通常在系统的PATH环境变量中，使 docker-compose可以全局运行） sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 测试是否安装成功： [root@dzx bin]# docker-compose version Docker Compose version v2.2.2 修改Docker配置 增加一段自定义内网 IPv6 地址 开启容器的 IPv6 功能 限制日志文件大小，防止 Docker 日志塞满硬盘 cat \u003e /etc/docker/daemon.json \u003c\u003cEOF { \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"20m\", \"max-file\": \"3\" }, \"ipv6\": true, \"fixed-cidr-v6\": \"fd00:dead:beef:c0::/80\", \"experimental\":true, \"ip6tables\":true } EOF 重启Docker服务:systemctl restart docker ","date":"2023-12-27","objectID":"/vaultwarden/:1:3","tags":[],"title":"密码管理器vaultwarden","uri":"/vaultwarden/"},{"categories":["Azure VPS"],"content":"Nginx Proxy Manager 安装Nginx Proxy Manager sudo -i mkdir -p /root/data/docker_data/npm cd /root/data/docker_data/npm 直接使用docker安装 cat \u003e docker-compose.yml \u003c\u003cEOF version: '3' services: app: image: 'jc21/nginx-proxy-manager:latest' restart: unless-stopped ports: - '80:80' # 保持默认即可，不建议修改左侧的80 - '81:81' # 冒号左边可以改成自己服务器未被占用的端口 - '443:443' # 保持默认即可，不建议修改左侧的443 volumes: - ./data:/data # 冒号左边可以改路径，现在是表示把数据存放在在当前文件夹下的 data 文件夹中 - ./letsencrypt:/etc/letsencrypt # 冒号左边可以改路径，现在是表示把数据存放在在当前文件夹下的 letsencrypt 文件夹中 EOF 运行访问Nginx Proxy Manage 直接 http://ip:81 访问，我这里就是 http://20.222.58.183:81/ 不知道服务器 IP，可以直接在命令行输入：`curl ip.sb`，会显示当前服务器的 IP ","date":"2023-12-27","objectID":"/vaultwarden/:1:4","tags":[],"title":"密码管理器vaultwarden","uri":"/vaultwarden/"},{"categories":["Azure VPS"],"content":"创建vaultwarden安装目录 sudo -i mkdir -p /root/data/docker_data/vaultwarden cd /root/data/docker_data/vaultwarden vim docker-compose.yml 写入以下设置 version: '3' services: vaultwarden: container_name: vaultwarden image: vaultwarden/server:latest restart: unless-stopped volumes: - ./data/:/data/ ports: - 8080:80 environment: - DOMAIN=https://subdomain.yourdomain.com # 这是您希望与您的Vaultwarden实例关联的域名。 - LOGIN_RATELIMIT_MAX_BURST=10 # 允许在一阵登录/两步验证尝试中的最大请求次数。 - LOGIN_RATELIMIT_SECONDS=60 # 这是来自同一IP的登录请求之间的平均秒数，在Vaultwarden限制登录次数之前。 - ADMIN_RATELIMIT_MAX_BURST=10 # 这与LOGIN_RATELIMIT_MAX_BURST相同，只争对admin面板。 - ADMIN_RATELIMIT_SECONDS=60 # 这与LOGIN_RATELIMIT_SECONDS相同 - ADMIN_SESSION_LIFETIME=20 # 会话持续时间 - ADMIN_TOKEN=YourReallyStrongAdminTokenHere # 此值是Vaultwarden管理员面板的令牌（一种密码）。为了安全起见，这应该是一个长的随机字符串。如果未设置此值，则管理员面板将被禁用。建议openssl rand -base64 48 生成ADMIN_TOKEN确保安全 - SENDS_ALLOWED=true # 此设置决定是否允许用户创建Bitwarden发送 - 一种凭证共享形式。 - EMERGENCY_ACCESS_ALLOWED=true # 此设置控制用户是否可以启用紧急访问其账户的权限。例如，这样做可以在用户去世后，配偶可以访问密码库以获取账户凭证。可能的值：true / false。 - WEB_VAULT_ENABLED=true # 此设置决定了网络保险库是否可访问。一旦您配置了您的账户和客户端，停止您的容器，然后将此值切换为false并重启Vaultwarden，可以用来防止未授权访问。可能的值：true/false。 - SIGNUPS_ALLOWED=true # 此设置控制新用户是否可以在没有邀请的情况下注册账户。可能的值：true / false。 CSDN markdown 格式博文，插入图片空行太大_为什么markdown中插入图片前后有很大空间空格-CSDN博客 ","date":"2023-12-27","objectID":"/vaultwarden/:2:0","tags":[],"title":"密码管理器vaultwarden","uri":"/vaultwarden/"},{"categories":["Azure VPS"],"content":"整Azure教育优惠，为期一年的超级自制VPS之旅 开整！！！ ","date":"2023-12-27","objectID":"/azure_vps/:0:0","tags":[],"title":"新建Azure's VPS","uri":"/azure_vps/"},{"categories":["Azure VPS"],"content":"创建Azure实例 创建linux虚拟机 区域是服务器所在的数据中心位置，这个选项会影响连接服务器的延时。一般来说，选择周边的国家和地区速度会快一些。可以在Azure Latency Test这个网站测试你的网络到不同数据中心的延时，也可以看到不同区域选项对应的真实地理位置，比如说East Asia对应的就是香港。如果你想通过服务器使用一些国外的服务，你也可能需要考虑一下服务器的位置。比如说要使用OpenAI的Chatgpt等服务，就不要选择East Asia。 延迟差距不大，为了省去备案以及日后折腾一些服务的麻烦，我这里就选择Japan East 剩下按照流程创建，选择系统版本balabala 其中： 映像就是服务器的操作系统。Linux系统的发行版众多，主要有Redhat和Debian两大分支。Redhat系下有RHEL，CentOS，Fedara等，Debian系下有Debian和Ubuntu等，除了这两系外还有许多其他的发行版。不同发行版的命令有一些差异，软件包也不同。 我手边有一本鸟叔的基础的Linux工具书，跟着书的版本选择Centos系列 总之我的Azure白嫖的vps创建好了 ","date":"2023-12-27","objectID":"/azure_vps/:1:0","tags":[],"title":"新建Azure's VPS","uri":"/azure_vps/"},{"categories":["Azure VPS"],"content":"密码以及免密登录 ","date":"2023-12-27","objectID":"/azure_vps/:2:0","tags":[],"title":"新建Azure's VPS","uri":"/azure_vps/"},{"categories":["Azure VPS"],"content":"启用root用户登录 \u0026 密码登录 修改配置文件 Azure下使用资源虚拟机时默认创建新用户 azureuser，名称可以自己改，但是禁止了以 root用户登录，我们可以通过修改 /etc/ssh/sshd_config (ssh配置文件) sudo -i #切换至root用户 vi /etc/ssh/sshd_config 在vim界面底层命令行模式下，可以使用 /\u003ckey\u003e快速定位需要修改的地方 我这里使用 /PermitRootLogin /PasswordAuthentication 修改成yes,启用root用户登录以及密码登录 在原处修改注意删除前面的注释符号`#` 修改密码 记得修改root以及自己用户密码 sudo passwd \u003cusername\u003e [root@dzx ~]# su -griedzx #切换用户 [griedzx@dzx ~]$ sudo passwd griedzx Changing password for user griedzx. New password: Retype new password: passwd: all authentication tokens updated successfully. 重启实例后 Reboot再ssh连接 ","date":"2023-12-27","objectID":"/azure_vps/:2:1","tags":[],"title":"新建Azure's VPS","uri":"/azure_vps/"},{"categories":["生物信息软件综合实践"],"content":"生物信息软件综合实践实验报告 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:0:0","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验题目 ：表达谱基本分析及查询 实验日期：2023年12月19日 星期二 实验者：生物信息2102 代子希 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:1:0","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验目的： 熟悉表达谱数据库的查询和数据下载 熟悉芯片表达谱数据分析的一般流程 掌握表达差异分析和基因富集分析的方法 了解常用的数据可视化方法 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:2:0","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验内容： GEO数据库查询和数据下载 使用R包limma进行差异表达分析 使用R包clusterProfiler进行基因富集分析 使用gplots、ggpubr、pheatmap等R包对差异表达和富集分析进行结果可视化 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:3:0","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验流程和结果 以 GSE46456为例，该实验使用的芯片平台为GPL198，拟南芥样本基因型包括：野生型、BRI1 单突变型、GUL2单突变型、BRI和GUL 双突变型，每种基因型设置三种重复。研究三种突变型样本与WT野生型样本哪些基因存在显著的差异表达。根据所提供的演示代码和相关文件，请完成以下任务： 对获得的芯片数据进行数据标准化、探针过滤、limma差异分析，写明每一步骤的代码、目的以及中间结果。 运用limma获得突变体和野生型的差异表达基因集，并阐述差异分析结果的各列含义。 对所有基因做GSEA富集分析；并对三组上调的差异表达基因（bri1-WT、gul2-WT、bri1_gul2-WT）做GO富集分析，并解释富集结果，如有图片请注明图注信息。 安装、加载包以及相关依赖 # R ≥ 3.5.0 if (!requireNamespace(\"BiocManager\", quietly = TRUE)) install.packages(\"BiocManager\") BiocManager::install(version = \"3.13\") library(BiocManager) install.packages(\"cluster\") install.packages(\"kohonen\") install.packages(\"gplots\") install.packages(\"ggpubr\") install.packages(\"ggthemes\") install.packages(\"pheatmap\") BiocManager::install(\"GEOquery\") BiocManager::install(\"RankProd\") BiocManager::install(\"affy\") BiocManager::install(\"affyPLM\") BiocManager::install(\"limma\") BiocManager::install(\"genefilter\") BiocManager::install(\"org.At.tair.db\") BiocManager::install(\"Mfuzz\") BiocManager::install(\"clusterProfiler\") library(RankProd) library(cluster) library(kohonen) library(gplots) library(RankProd) library(affy) library(affyPLM) packageurl \u003c- \"https://bioconductor.org/packages//2.7/bioc/src/contrib/simpleaffy_2.64.0.tar.gz\" install.packages(packageurl, repos = NULL, type = \"source\") library(genefilter) library(gcrma) options(BioC_mirror=\"https://mirrors.tuna.tsinghua.edu.cn/bioconductor\") install.packages(\"https://github.com/SiYangming/simpleaffy/releases/download/v2.64.0/simpleaffy_2.64.0.tar.gz\", repos = NULL, type = \"source\", dependencies = TRUE) library(simpleaffy) library(RColorBrewer) library(limma) library(pheatmap) library(Mfuzz) library(clusterProfiler) library(enrichplot) library(ggplot2) library(\"org.At.tair.db\",character.only = TRUE) 其中simpleaffy 使用源代码安装 packageurl \u003c- \"https://bioconductor.org/packages/3.8/bioc/src/contrib/simpleaffy_2.58.0.tar.gz\" install.packages(packageurl, repos=NULL, type=\"source\") 下载数据 用 GEOquery 中 getGEOSuppFiles() 函数直接下载，指定下载路径 library(GEOquery) getGEOSuppFiles(\"GSE46456\", baseDir = \"F:/tmp_data\") 报错 Error in getGEOSuppFiles(\"GSE46456\", baseDir = \"F:/tmp_data\") : Failed to download F:/tmp_data/GSE46456/GSE46456_RAW.tar! 也许是网络原因，命令行使用代理也不行，直接到GEO数据库网页端下载芯片数据，在本地解压 #生成文件列表，以便批量导入文件 cels = list.files(\"./data/GSE46456/\",pattern=\"*.gz\",full.names =TRUE) # 读取CEL文件，将其处理成AffyBatch对象 celfiles \u003c- ReadAffy(filenames=cels) ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:4:0","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"数据预处理 # 将AffyBatch对象转换为ExpressionSet对象,对数据进行标准化 celfiles.rma \u003c- rma(celfiles) Error in getCdfInfo(object) : Could not obtain CDF environment, problems encountered: Specified environment does not contain ATH1-121501 Library - package ath1121501cdf not installed Bioconductor - could not connect 此外: Warning message: In readLines(biocURL) : URL 'https://master.bioconductor.org/': status was 'SSL connect error' 根据报错安装相关包 if (!requireNamespace(\"BiocManager\", quietly = TRUE)) install.packages(\"BiocManager\") BiocManager::install(\"ath1121501cdf\") # 将AffyBatch对象转换为ExpressionSet对象,对数据进行标准化 celfiles.rma \u003c- rma(celfiles) #?rma cols \u003c- brewer.pal(8,\"Set1\") ?rma rma {affy} Robust Multi-Array Average expression measure Description This function converts an AffyBatch object into an ExpressionSet object using the robust multi-array average (RMA) expression measure. pdf(\"./png/boxplot_celfiles.pdf\") boxplot(celfiles, col=cols) dev.off() pdf(\"./png/boxplot_celfiles_rma.pdf\") boxplot(celfiles.rma, col=cols) dev.off() #放在一张图上,对比 pdf(\"./png/boxplot_celfiles_celfiles_rma.pdf\", width=20, height=5) par(mfrow = c(1,2)) boxplot(celfiles, col=cols, main = \"Raw Data\") boxplot(celfiles.rma, col=cols, main = \"RMA Data\") par(mfrow = c(1,1)) dev.off() #密度和对数强度直方图 pdf(\"./png/hist_celfiles.pdf\") hist(celfiles, col=cols) dev.off() pdf(\"./png/hist_celfiles_rma.pdf\") hist(celfiles.rma, col=cols) dev.off() 对比箱线图 对比标准化前后的数据，经过标准化后12个样本的数据分布更趋同 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:4:1","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"探针过滤 #对ExpressionSet的探针进行过滤（过滤掉表达量低的探针），返回一个list celfiles.filtered \u003c- nsFilter(celfiles.rma, require.entrez=FALSE, remove.dupEntrez=FALSE) #list中的eset为过滤后的ExpressionSet，filter.log为每一步过滤到多少探针的记录 \u003e celfiles.filtered$filter.log $numLowVar [1] 11373 $feature.exclude [1] 64 \u003e celfiles.filtered$eset ExpressionSet (storageMode: lockedEnvironment) assayData: 11373 features, 12 samples element names: exprs protocolData sampleNames: GSM1130596_Ws-2-1.CEL.gz GSM1130597_Ws-2-2.CEL.gz ... GSM1130607_gul2-1bri1-5-3.CEL.gz (12 total) varLabels: ScanDate varMetadata: labelDescription phenoData sampleNames: GSM1130596_Ws-2-1.CEL.gz GSM1130597_Ws-2-2.CEL.gz ... GSM1130607_gul2-1bri1-5-3.CEL.gz (12 total) varLabels: sample varMetadata: labelDescription featureData: none experimentData: use 'experimentData(object)' Annotation: ath1121501 #获得过滤后的表达矩阵 eset \u003c- exprs(celfiles.filtered$eset) 表达量矩阵，每一行表示一个探针(基因)，每一列为一个样本 \u003e head(eset) GSM1130596_Ws-2-1.CEL.gz GSM1130597_Ws-2-2.CEL.gz 244901_at 5.224648 5.428151 244902_at 5.149407 5.187442 244903_at 5.592680 5.436074 244904_at 4.985820 5.072172 244906_at 5.727308 5.889640 244912_at 6.465566 6.586064 GSM1130598_Ws-2-3.CEL.gz GSM1130599_bri1-5-1.CEL.gz 244901_at 5.546510 4.683135 244902_at 4.886097 4.672779 244903_at 5.638751 5.562216 244904_at 5.262937 5.016912 244906_at 5.323069 5.381804 244912_at 6.814510 7.653073 GSM1130600_bri1-5-2.CEL.gz GSM1130601_bri1-5-3.CEL.gz 244901_at 4.753393 4.463033 244902_at 4.805556 4.794880 244903_at 5.622267 5.224591 244904_at 5.446725 5.482161 244906_at 5.609199 5.514687 244912_at 7.871753 8.260488 GSM1130602_gul2-1-1.CEL.gz GSM1130603_gul2-1-2.CEL.gz 244901_at 6.087000 5.868863 244902_at 5.527636 5.592619 244903_at 6.605356 6.062327 244904_at 5.366306 5.495490 244906_at 6.348055 6.080350 244912_at 8.052288 7.970124 GSM1130604_gul2-1-3.CEL.gz GSM1130605_gul2-1bri1-5-1.CEL.gz 244901_at 5.386404 5.490967 244902_at 5.927320 5.302640 244903_at 5.597098 6.694592 244904_at 5.026725 5.257816 244906_at 6.218219 6.613726 244912_at 7.871955 7.620157 GSM1130606_gul2-1bri1-5-2.CEL.gz GSM1130607_gul2-1bri1-5-3.CEL.gz 244901_at 5.671008 5.305481 244902_at 5.524203 5.494279 244903_at 6.661931 6.565135 244904_at 5.356717 5.228070 244906_at 6.537190 6.425924 244912_at 7.387385 7.555005 \u003e colnames(eset) [1] \"GSM1130596_Ws-2-1.CEL.gz\" \"GSM1130597_Ws-2-2.CEL.gz\" [3] \"GSM1130598_Ws-2-3.CEL.gz\" \"GSM1130599_bri1-5-1.CEL.gz\" [5] \"GSM1130600_bri1-5-2.CEL.gz\" \"GSM1130601_bri1-5-3.CEL.gz\" [7] \"GSM1130602_gul2-1-1.CEL.gz\" \"GSM1130603_gul2-1-2.CEL.gz\" [9] \"GSM1130604_gul2-1-3.CEL.gz\" \"GSM1130605_gul2-1bri1-5-1.CEL.gz\" [11] \"GSM1130606_gul2-1bri1-5-2.CEL.gz\" \"GSM1130607_gul2-1bri1-5-3.CEL.gz\" ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:4:2","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"探针注释 注释探针: 防止非特异性结合造成的干扰(会有多个探针检测同一个基因的表达)。 先对探针进行注释，确定每个探针对应检测哪个基因的表达，然后再合并重复探针 ara_anno \u003c- read.delim(\"./data/affy_ATH1_array_elements-2010-12-20.txt\") ids \u003c- match(rownames(eset), ara_anno$array_element_name) rownames(eset) \u003c- ara_anno$locus[ids] colnames(eset) \u003c- sub(\".CEL.gz\",\"\",colnames(eset)) 规范矩阵的行名和列名 \u003e head(eset) GSM1130596_Ws-2-1 GSM1130597_Ws-2-2 GSM1130598_Ws-2-3 ATMG00640 5.224648 5.428151 5.546510 ATMG00650 5.149407 5.187442 4.886097 ATMG00660 5.592680 5.436074 5.638751 ATMG00670 4.985820 5.072172 5.262937 ATMG00690 5.727308 5.889640 5.323069 AT2G07783;ATMG00830 6.465566 6.586064 6.814510 GSM1130599_bri1-5-1 GSM1130600_bri1-5-2 GSM1130601_bri1-5-3 ATMG00640 4.683135 4.753393 4.463033 ATMG00650 4.672779 4.805556 4.794880 ATMG00660 5.562216 5.622267 5.224591 ATMG00670 5.016912 5.446725 5.482161 ATMG00690 5.381804 5.609199 5.514687 AT2G07783;ATMG00830 7.653073 7.871753 8.260488 GSM1130602_gul2-1-1 GSM1130603_gul2-1-2 GSM1130604_gul2-1-3 ATMG00640 6.087000 5.868863 5.386404 ATMG00650 5.527636 5.592619 5.927320 ATMG00660 6.605356 6.062327 5.597098 ATMG00670 5.366306 5.495490 5.026725 ATMG00690 6.348055 6.080350 6.218219 AT2G07783;ATMG00830 8.052288 7.970124 7.871955 GSM1130605_gul2-1bri1-5-1 GSM1130606_gul2-1bri1-5-2 ATMG00640 5.490967 5.671008 ATMG00650 5.302640 5.524203 ATMG00660 6.694592 6.661931 ATMG00670 5.257816 5.356717 ATMG00690 6.613726 6.537190 AT2G07783;ATMG00830 7.620157 7.387385 GSM1130607_gul2-1bri1-5-3 ATMG00640 5.305481 ATMG00650 5.494279 ATMG00660 6.565135 ATMG00670 5.228070 ATMG00690 6.425924 AT2G07783;ATMG00830 7.555005 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:4:3","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"limma差异分析 构建分组矩阵 group_list = c(rep(\"wt\",3), rep(\"bri1\",3), rep(\"gul2\",3), rep(\"gul_bri\",3)) design \u003c- model.matrix(~0+factor(group_list)) colnames(design) \u003c- levels(factor(group_list)) rownames(design) \u003c- colnames(eset) 构建分组矩阵，和野生型作比较 contrast.matrix\u003c- makeContrasts(bri1-wt, gul2-wt, gul_bri-wt,levels =design) contrast.matrix limma三部曲：线性模型拟合 根据对比模型进行差值计算 贝叶斯检验 #limma\"三部曲\" fit1 \u003c- lmFit(eset,design)#线性模型拟合 fit2 \u003c- contrasts.fit(fit1,contrast.matrix)#根据对比模型进行差值计算 fit2 \u003c- eBayes(fit2)#贝叶斯检验 输出差异表达基因 #利用toptable 导出DEG结果 limma_results \u003c- lapply(colnames(contrast.matrix),function(x){topTable(fit2,coef=x,adjust=\"fdr\",sort.by=\"logFC\",number=Inf)}) length(limma_results) names(limma_results) \u003c- colnames(contrast.matrix) #对导出的结果标记title信息 head(limma_results[[1]]) save(limma_results,file=\"./data/limma_compare_res.RData\") #对每对比较的样本对DEG结果单独导出DEG信息6 for (n in names(limma_results)){ write.table(limma_results[[n]],file = sprintf(\"%s.tsv\",paste0(\"./data/\", gsub(\" \",\"\",n))),row.names =FALSE,sep=\"\\t\") } save(eset,file=\"./data/eset.RData\") 差异分析结果解释 一共有三组结果，去循环最后一个文件查看 \u003e n [1] \"gul_bri - wt\" \u003e colnames(limma_results[[n]]) [1] \"ID\" \"logFC\" \"AveExpr\" \"t\" \"P.Value\" \"adj.P.Val\" [7] \"B\" \u003e head(limma_results[[n]]) ID logFC AveExpr t P.Value adj.P.Val B 2773 AT5G12030 4.279782 8.119452 41.36505 1.465057e-20 1.666210e-16 37.01501 9250 AT2G40170 4.106650 7.424729 39.00006 4.589678e-20 2.609920e-16 35.95876 1669 AT5G54190 3.931407 8.501771 35.62676 2.644989e-19 5.013576e-16 34.31203 6603 AT3G15670 3.917131 7.540334 35.89093 2.292873e-19 5.013576e-16 34.44747 9416 AT2G21490 3.909309 6.788934 31.58778 2.697592e-18 2.045314e-15 32.08537 46 ATCG00790 3.901580 10.302096 34.51467 4.882151e-19 7.932100e-16 33.72882 ID : Gene ID logFC : 两组表达值之间以2为底对数化的变化倍数（Fold change, FC），由于基因表达矩阵本身已经取了对数，这里是两组基因表达值均值之差 AveExpr ：该探针组所在所有样品中的平均表达值 t ：贝叶斯调整后的两组表达值间 T 检验中的 t 统计量 P.Value : 检验P值 adj.P.Val ：调整后的 P 值（多重检验BH等方法） B ：是经验贝叶斯得到的标准差的对数化值 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:4:4","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"差异表达分析结果可视化 热图 pdf(\"./png/heatmap.pdf\") pheatmap(eset, col=c(colorRampPalette(brewer.pal(9,\"Blues\")[7:2])(100),colorRampPalette(brewer.pal(9,\"Reds\")[2:7])(100)),border_color=NA,cluster_rows=T,cluster_cols=T,show_rownames=F,show_colnames=T,angle_col=315,fontsize=13,main=\"expression\",display_numbers=F) dev.off() 颜色的深浅来反映数值的高低，聚类反映不同基因和不同样本之间的表达量相似性 火山图 library(ggpubr) library(ggthemes) for (n in names(limma_results)){ file_name = sprintf(\"%s.tsv\",paste0(\"./data/\", gsub(\" \",\"\",n))) deg.data \u003c- read.table(file_name,header=T, sep=\"\\t\") deg.data$logP \u003c- -log10(deg.data$adj.P.Val) deg.data$Group = \"not-significant\" #定义Group列 deg.data$Group[which ((deg.data$adj.P.Val \u003c 0.05) \u0026 (deg.data$logFC \u003e 2))] = \"up-regulated\" #定义DEG标准 deg.data$Group[which ((deg.data$adj.P.Val \u003c 0.05) \u0026 (deg.data$logFC \u003c -2))] = \"down-regulated\" #定义DEG标准 table(deg.data$Group) pdf(sprintf(\"./png/%s.pdf\",paste0(gsub(\" \",\"\",n)))) ggscatter(deg.data, x=\"logFC\",y = \"logP\",color = \"Group\") + theme_base() + labs(title = n) dev.off() } #新加一列lable deg.data$Lable = \"\" #对差异表达基因P值从小到大排序 deg.data \u003c- deg.data[order(deg.data$adj.P.Val),] #从高表达基因中选取adj.P.Val最显著的10个基因 up.genes \u003c- head(deg.data$ID[which(deg.data$Group == \"up-regulated\")],10) #从低表达基因中选取adj.P.Val最显著的10个基因 down.genes \u003c- head(deg.data$ID[which(deg.data$Group == \"down-regulated\")],10) # 讲上两步选取的显著基因合并并加入到lable中 deg.top10.genes \u003c- c(as.character(up.genes), as.character(down.genes) ) deg.data$Lable[match(deg.top10.genes, deg.data$ID)] \u003c- deg.top10.genes png(\"./png/plot2.png\", res = 300, width = 10, height = 10, units = \"in\") ggscatter(deg.data, x=\"logFC\", y = \"logP\", color = \"Group\", palette = c(\"#2f5688\", \"#BBBBBB\", \"#CC0000\"), size = 1, label = deg.data$Lable, font.label = 8, repel = T, xlab = \"Log2FoldChange\", ylab=\"-Log10(Adjust P-value)\",) + theme_base() + geom_hline(yintercept = 1.30, linetype=\"dashed\") + geom_vline(xintercept = c(-2,2), linetype=\"dashed\") dev.off() 富集分析 首先进行GSEA for (n in names(limma_results)){ file_name \u003c- sprintf('%s.tsv', paste0(\"./data/\", gsub(\" \", \"\", n))) GSEA_data \u003c- read.table(file_name, header = T, sep = \"\\t\") GSEA_gene_lists \u003c- GSEA_data$logFC #提取表达量变化值 names(GSEA_gene_lists) \u003c- GSEA_data$ID #给提取出来的值赋予ID GSEA_gene_lists \u003c- sort(GSEA_gene_lists, decreasing = TRUE)#降序排列 organisms \u003c- get(\"org.At.tair.db\") #获取拟南芥数据库信息 #GSEA富集分析 GSEA_GO_Result \u003c- gseGO( geneList = GSEA_gene_lists, ont = \"ALL\", keyType = \"TAIR\", nPerm = 10000, minGSSize = 3, maxGSSize = 800, pvalueCutoff = 0.05, verbose = TRUE, OrgDb = organisms , pAdjustMethod = \"none\" ) Sort_GO_result \u003c- GSEA_GO_Result[order(GSEA_GO_Result$enrichmentScore, decreasing = T),] write.table(Sort_GO_result,paste(file_name,'GSEA_GO_Result.txt',sep = '_'),sep = \"\\t\",quote = F,col.names = T,row.names = F) GSEA_GO_Result_plot \u003c- gseaplot2(GSEA_GO_Result, row.names(Sort_GO_result)[1:4], title = n) png(filename = paste(file_name,'GSEA_GO_Result.png',sep = '_'),width = 3580,height = 2200,res = 300) print(GSEA_GO_Result_plot) dev.off() GSEA_GO_Result_plot2 \u003c- gseaplot(GSEA_GO_Result,by=\"all\",title = GSEA_GO_Result$Description[1],geneSetID=1) png(filename = paste(file_name,'GSEA_GO_Result2.png',sep = '_'),width = 3580,height = 2200,res = 300) print(GSEA_GO_Result_plot2) dev.off() } 通过 row.names(Sort_GO_result)[1:4]指定每一组中富集分数最高的四个term画富集条码图 对三组上调的差异表达基因（bri1-WT、gul2-WT、bri1_gul2-WT）做GO富集分析 for (n in names(limma_results)){ file_name \u003c- sprintf('%s.tsv',paste0(\"./data/\", gsub(\" \", \"\", n))) deg.data \u003c- read.table(file_name, header = T, sep = \"\\t\") deg.data$logP \u003c- -log10(deg.data$adj.P.Val) #-log10值转换 deg.data$Group = \"not-significant\" #定义Group列 deg.data$Group[which ((deg.data$adj.P.Val \u003c 0.05) \u0026 (deg.data$logFC \u003e 2))] = \"up-regulated\" #定义DEG标准 deg.data$Group[which ((deg.data$adj.P.Val \u003c 0.05) \u0026 (deg.data$logFC \u003c -2))] = \"down-regulated\" #定义DEG标准 data\u003c- deg.data[deg.data$Group==\"up-regulated\",] ego \u003c- enrichGO(gene = data$ID,keyType = \"TAIR\",OrgDb=organisms,ont=\"ALL\",pAdjustMethod=\"BH\",qvalueCutoff=0.05) png(file = paste(file_name,'GO_dot.png',sep = '_'),bg=\"t","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:4:5","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"思考与讨论 1.为什么要对探针信号或基因表达量取对数？为什么是log2不是log10或lg? 在芯片数据分析中，对探针信号或基因表达量取对数是为了减小数据的离散程度，使得数据更加符合正态分布。取对数后，数据的性质和相对关系不会受到影响。 用log2，因为基因表达量增加1倍被认为就可以造成生物学上的一些变化，而且如果前面是对表达量取log2，后面计算fold-chage就可以直接相减。 2.为什么要设置生物学重复？ 由于遗传和环境等因素的影响会引起有机体的个体差异，因此需要采用生物重复的实验设计方法来消除该差异。对同一个处理组中独立来源的多个样本分别进行独立测定分析，是整个实验的完全重复。设计生物重复可以： 能够消除组内误差：生物学重复可以测量变异程度； 增强结果的可靠性：测序的样本数越多，越能够降低背景差异； 检测离群样本：异常样本的存在，会严重影响测序结果的准确性，通过计算样本间的相关性可以发现异常样本，将其排除。 3.芯片数据差异表达分析和富集分析中，分别需要用到哪些算法、统计模型和检验？ 在芯片数据差异表达分析中，常用的算法和统计模型包括： 倍数分析方法：倍数变换fold change，单纯的case与control组表达值相比较，对没有重复实验样本的芯片数据，或者双通道数据采用这种方法。 参数法分析（t检验）：当t超过根据可信度选择的标准时, 比较的两样本被认为存在着差异。但小样本基因芯片实验会导致不可信的变异估计，此时采用调节性T检验。 非参数分析：由于微阵列数据存在“噪声”干扰而且不满足正态分布假设，用t检验有风险。非参数检验并不要求数据满足特殊 在富集分析中，常用的统计方法包括累计超几何分布和Fisher精确检验。由于在进行富集分析时通常需要同时进行大量检验（多重检验），所以需要采用多重检验校正的方法对检验结果进行校正，常用的校正方法包括Bonferroni校正和Benjiamini false discovery rate校正。 ","date":"2023-12-24","objectID":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:5:0","tags":[],"title":"表达谱分析","uri":"/%E8%A1%A8%E8%BE%BE%E8%B0%B1%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"生物信息软件综合实践实验报告 ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:0:0","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验题目 ：基因预测和基因结构分析 实验日期：2023年12月5日 星期二 实验者：生物信息2102代子希 ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:1:0","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验目的： 1.掌握常用基因从头预测软件的使用和结果解读 2.熟悉文件格式GFF3的基本信息 3.熟悉至少一种基因组浏览器的使用 4.了解基因结构和非编码基因预测等分析 ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:2:0","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验内容： 1.使用软件Prodigal预测大肠杆菌Escherichia coli K12基因组的基因，并对预测结果进行总结 2.至少使用两种基因从头预测软件预测拟南芥基因组（部分序列）的基因，并对预测结果进行总结和差异比较。 3.使用IGV查看拟南芥重要基因的注释结果 ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:3:0","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"实验流程和结果 问题1 1.使用Prodigal对组装的大肠杆菌的序列（其中1Mb序列，已提供，见文件ecoli.hifi.fa）进行基因预测，统计预测得到的基因的数量 步骤1：使用prodigal命令 mkdir prodigal cd prodigal prodigal -a ref.pep -d ref.cds -f gff -g 11 -o ref.gff -p single -s ref.stat -i ../../data/ch06/ecoli.hifi.fa \u0026 \u003eprodigal.log \u0026 ref.cds 输出的预测基因的序列文件 ref.gff 输出的基因的位置信息gff文件 ref.pep 输出的预测序列的氨基酸文件 ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:4:0","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"prodigal文件夹下结果 步骤2：统计预测得到的基因的数量 ①使用awk命令对gff文件进行统计 awk '/^#/ {next} {if ($3 == \"CDS\") count++} END {print count}' ref.gff ②使用grep命令对ref.cds文件进行统计 grep -c \"\u003e\" ref.cds 问题2 2.从给定的拟南芥基因组（TAIR10版本）的某段序列（二号染色体7.5-8.5Mb,文件名：Ath.1mb.fa），完成以下任务： 使用GenScan、Augustus、GlimmerHMM等软件（至少两种软件）预测该序列所包含的蛋白质编码基因。统计不同软件组装得到的基因和外显子（exon）的数量，并选用适当的图表（如直方图）将统计结果进行展示。 从TAIR10网站下载该区间的基因注释信息（已下载到服务器，见文件tair10.ch2_7.5-8.5Mb.genes.gff3），作为标准参考集，试评估第1）题中使用的不同软件预测结果的准确率和召回率等。（可以考虑从基因、exon、CDS等水平上进行比较，比如：对于某个基因，augustus预测的跟tair10的基因重叠区域超过各自注释区间的90%，则认为两者一致，其他exon、CDS的比较，可采用相同标准） 试列举1-2个基因在不同软件和TAIR10中的注释差异情况（结合IGV展示不同软件的注释结果）。可参考的基因：WUS、PHYTOCHROMEB 问题2.1 步骤1：使用Augustus预测 对需要使用的数据创建软连接，使用Augustus预测 cd augustus ln -sf /home/uu02/data/ch06/Ath.1mb.fa ./ augustus --species=arabidopsis Ath.1mb.fa 1\u003eaugustus.out 2\u003elog.txt \u0026 步骤2：对组装结果augustus.out统计得到基因和外显子的数量 Augusuts预测结束后得到了 augustus.out文件，这个文件本质是一个gff格式的文件，文件前半部分是一些 #开头的注释 # 统计基因的数量 gene_count=$(awk -F '\\t' '$3==\"gene\"' augustus.out | wc -l) # 统计外显子的数量 exon_count=$(awk -F '\\t' '$3==\"exon\"' augustus.out | wc -l) # 打印结果 echo \"基因的数量: $gene_count\" echo \"外显子的数量: $exon_count\" **步骤3：**使用GlimmerHMM预测 对需要使用的数据创建软连接，使用GlimmerHMM预测 cd glimmerhmm ln -sf /home/uu02/data/ch06/Ath.1mb.fa ./ glimmerhmm Ath.1mb.fa -d /home/uu02/software/07_GlimmerHMM/GlimmerHMM/trained_dir/arabidopsis -g -n 1 1\u003eref.gff 2\u003elog.txt \u0026 **步骤4：**对组装结果ref.gff统计得到基因和外显子的数量 组装结果也是gff文件，观察发现GlimmerHMM 的预测结果将 gene 和 exon 信息写在了 “Note” 属性中,并且 gene 信息在 “mRNA” 类型的行中 # 统计基因的数量 gene_count=$(awk -F '\\t' '$3==\"mRNA\"' ref.gff | wc -l) # 统计外显子的数量 exon_count=$(awk -F '\\t' '$9 ~ /exon/' ref.gff | wc -l) # 打印结果 echo \"基因的数量: $gene_count\" echo \"外显子的数量: $exon_count\" **步骤5：**选用适当的图表（如直方图）将统计结果进行展示 import matplotlib.pyplot as plt import numpy as np # 设置gene和extron的count counts = {'augustus': {'gene': 228, 'extron': 1360}, 'glimmerHMM': {'gene': 234, 'extron': 1245}} # 创建堆叠的直方图 labels = list(counts.keys()) gene_counts = [counts[label]['gene'] for label in labels] exon_counts = [counts[label]['extron'] for label in labels] x = np.arange(len(labels)) # the label locations width = 0.35 # the width of the bars fig, ax = plt.subplots() rects1 = ax.bar(x - width/2, gene_counts, width, label='gene') rects2 = ax.bar(x + width/2, exon_counts, width, label='extron') #加上具体的数值 for rect in rects1: height = rect.get_height() ax.annotate('{}'.format(height), xy=(rect.get_x()+rect.get_width()/2, height), xytext=(0,3), # 3 points vertical offset textcoords=\"offset points\", ha='center', va='bottom') for rect in rects2: height = rect.get_height() ax.annotate('{}'.format(height), xy=(rect.get_x()+rect.get_width()/2, height), xytext=(0,3), # 3 points vertical offset textcoords=\"offset points\", ha='center', va='bottom') ax.set_ylabel('count') ax.set_title('gene \u0026 extron count') ax.set_xticks(x) ax.set_xticklabels(labels) #图例放在表格外面 ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.) fig.tight_layout() plt.show() ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:4:1","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"augustus文件夹下结果 部分预测结果 ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:4:2","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"prodigal文件夹下结果 部分预测结果 问题2.2 不同软件预测结果的准确率和召回率 **步骤1：**使用bedtools intersectbed模块获取重叠部分符合要求的结果 -a -b 指定输入文件 -f 0.9 指定重叠部分最少所占比列 -r 指定重叠部分所占比例在 a 与 b中同时满足 \u003e 0.9 #!/bin/bash augustus='/home/uu02/02_dzx/augustus/augustus.out' glimmerHMM='/home/uu02/02_dzx/glimmerhmm/ref.gff' ref_data='/home/uu02/data/ch06/tair10.ch2_7.5-8.5Mb.genes.gff3' for file in $augustus $glimmerHMM do dir=$(basename $(dirname $file)) intersectBed -a $ref_data -b $file -f 0.9 -r -wao \u003e $dir.intersect done 步骤2： 文件导入本地，用python统计召回率 ：实际为正的样本中被预测为正样本的概率 召回率=TP/(TP+FN) 实际为正的样本数为 ref_data 参考数据中注释为gene / exon的行 实际为正 统计为真的样本，根据不同软件预测结果格式筛选 augustus: gene: data[(data[11] == 'gene') \u0026 (data[2] == 'gene')] exon: (data[11] == 'exon') \u0026 (data[2] == 'exon')] gil mmerhmm: gene: data[(data[11] == 'mRNA') \u0026 (data[2] == 'gene')] exon: data[(data[2] == 'exon') \u0026 (data[17].str.contains('exon'))] import os import pandas as pd #分别从gene、exon水平通过召回率评估不同软件预测结果 file = ['F:/生物信息软件综合实践/05_data/augustus.intersect', 'F:/生物信息软件综合实践/05_data/glimmerhmm.intersect'] ref_data = pd.read_csv('F:/生物信息软件综合实践/05_data/tair10.ch2_7.5-8.5Mb.genes.gff3', sep='\\t', header=None) ref_data_gene = ref_data[ref_data[2] == 'gene'] ref_data_exon = ref_data[ref_data[2] == 'exon'] for f in file: data = pd.read_csv(f, sep='\\t', header=None) software = os.path.basename(f).split('.')[0] #gene g_p_e = len(ref_data_gene) e_p_e = len(ref_data_exon) if software == 'augustus': g_tp = len(data[(data[11] == 'gene') \u0026 (data[2] == 'gene')]) g_recall = g_tp / g_p_e e_tp = len(data[(data[11] == 'exon') \u0026 (data[2] == 'exon')]) e_recall = e_tp / e_p_e print('augustus gene recall: %s, and turn to percentage: %s %%' % (g_recall, format(g_recall*100, '.2f'))) print('augustus exon recall: %s, and turn to percentage: %s %%' % (e_recall, format(e_recall*100, '.2f'))) #转换成百分比 elif software == 'glimmerhmm': g_tp = len(data[(data[11] == 'mRNA') \u0026 (data[2] == 'gene')]) g_recall = g_tp / g_p_e e_tp = len(data[(data[2] == 'exon') \u0026 (data[17].str.contains('exon'))]) e_recall = e_tp / e_p_e print('glimmerhmm gene recall: %s, and turn to percentage: %s %%' % (g_recall, format(g_recall*100, '.2f'))) print('glimmerhmm exon recall: %s, and turn to percentage: %s %%' % (e_recall, format(e_recall*100, '.2f'))) recall(召回率) gene exon glimmerhmm 12.75% 58.35% augustus 46.61% 68.29% 问题2.3 列举1-2个基因在不同软件和TAIR10中的注释差异情况（结合IGV展示不同软件的注释结果）。可参考的基因：WUS、PHYTOCHROMEB ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:4:3","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":["生物信息软件综合实践"],"content":"思考与讨论 1.原核生物的基因结构（组成单元、长度、GC含量等）和真核生物的基因结构有哪些差异？（结合大肠杆菌和拟南芥的注释进行分析讨论） 2.不如软件的基因预测结果，有哪些差异？为什么会有这些差异？相比于标准集，哪个软件的预测结果可能相对最好？试结合算法原理，进行讨论 1.原核生物和真核生物的基因结构差异： 原核生物（以大肠杆菌为例），原核生物基因没有内含子,一个基因对应一个连续的mRNA和蛋白质，大肠杆菌基因主要由连续的开放阅读框（ORF）组成，其中包含了编码蛋白质的基因。这些基因通常没有被包裹在真正的细胞核中，而是在细胞质中存在。原核生物基因整体较短,大多数大肠杆菌基因长度小于1000bp，典型的蛋白编码基因长度约为几百到几千个碱基对，原核生物基因前的启动子区域保守,存在信号序列如-10和-35元件 真核生物（以拟南芥为例），真核生物基因由外显子和内含子组成，外显子为编码蛋白质的区域，而内含子则是非编码序列。这些基因通常位于真正的细胞核中，即真核生物基因含有内含子,需要剪接处理长度：。真核生物基因通常较长，其中包含有复杂的调控元件和结构。蛋白编码基因的长度可能达到数千到数万个碱基对，拟南芥等真核生物基因往往很长,部分基因可达几十万bp。拟南芥等高等真核生物基因区GC含量差异较大。真核生物启动子区域结构较复杂,需多个转录因子互作才能启动转录，真核生物同属基因序列保守性差异大,难以仅依靠序列相关性预测基因 2.基因预测软件结果与实际差异的原因以及算法比较： 算法原理:augustus使用生成式隐马尔可夫模型,genscan和glimmerhmm使用隐马尔可夫模型 预测内容:augustus可以预测外显子-内含子结构,genscan和glimmerhmm仅预测外显子 因此: augustus利用了更丰富的外部信息,理论上预测精度应最高 genscan和glimmerhmm仅依靠序列本身,难免会漏预测真实基因或者错误预测假基因 对于拟南芥这类有丰富注释的数据,以augustus训练得到的模型进行预测效果应最好 对于基因组注释不全的物种,三者效果相对,Glimmerhmm可能效果最好 从本次实验计算的召回率以及上述分析，总体来说,利用外部信息(如注释)训练模型进行预测的augustus,在条件允许的情况下,它的预测结果可靠性应最高。 ","date":"2023-12-24","objectID":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/:5:0","tags":[],"title":"基因预测和基因结构分析","uri":"/%E5%9F%BA%E5%9B%A0%E9%A2%84%E6%B5%8B%E5%92%8C%E5%9F%BA%E5%9B%A0%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"},{"categories":[],"content":"mamba安装 推荐安装方式 curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\" bash Miniforge3-$(uname)-$(uname -m).sh curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\"：这条命令使用 curl 工具从 GitHub 上下载 Miniforge 的最新版本。-L 参数让 curl 能够处理重定向，-O 参数让 curl 使用 URL 的文件名保存文件。$(uname) 和 $(uname -m) 是 shell 命令，它们分别返回操作系统的名称和机器硬件名称（例如，Linux x86_64），这样可以下载适合当前系统的 Miniforge 版本。 bash Miniforge3-$(uname)-$(uname -m).sh：这条命令使用 bash shell 执行下载的 Miniforge 安装脚本。 ","date":"2023-12-07","objectID":"/mamba/:0:0","tags":[],"title":"Mamba","uri":"/mamba/"},{"categories":[],"content":"首页 | SakuraFrp 帮助文档 (natfrp.com) ","date":"2023-11-29","objectID":"/sakurafrp/:0:0","tags":[],"title":"SakuraFrp","uri":"/sakurafrp/"},{"categories":["Deep Learning from Scratch 学习笔记"],"content":"感知机 x是输入信号，y是输出信号，w(weight)是权重 输入信号分别乘以固定的权重(w*x)，传输至下一个神经元，超过某一个阈值(theta)时输出1，表示“神经元被激活” 通过改变感知机的参数（w,theta）,也就是权重和阈值，相同构造的感知机可以表示与门、与非门、或门 与非门真值表 与门正值表 或门真值表 ","date":"2023-11-28","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/:1:0","tags":[],"title":"学习记录(1)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"categories":["Deep Learning from Scratch 学习笔记"],"content":"简单实现 #与门 def AND(x1, x2): w1, w2, theta = 0.5, 0.5, 0.7 tmp = w1*x1 + w2*x2 if tmp \u003c= theta: return 0 elif tmp \u003e theta: return 1 与非门的参数可以直接时 与门参数值的符号取反 ","date":"2023-11-28","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/:1:1","tags":[],"title":"学习记录(1)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"categories":["Deep Learning from Scratch 学习笔记"],"content":"导入权重与偏置 将阈值（theta）换成-b,公式变形，也就是上式，同样可以表达感知机 感知机会计算输入信号和权重的乘积，然后加上偏置，通过与0大小判断来决定是否激活神经元 numpy实现感知机 import numpy as np def AND(x1, x2): x = np.array([0,1]) #input w = np.array([0.5, 0.5]) #weight b = -0.7 #bias tmp = np.sum(w*x) + b if tmp \u003c= 0: return 0 else: return 1 #直接修改w b可以分别实现与非门以及或门 w权重用于控制输入信号重要性占比，(-theta)偏置(b)用于调整神经元被激活的容易程度 ","date":"2023-11-28","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/:1:2","tags":[],"title":"学习记录(1)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"categories":["Deep Learning from Scratch 学习笔记"],"content":"局限性 单层感知机无法直接实现异或门（仅有一者为整输出1）（异或：拒绝其他） 感知机可视化 上述构造的感知机，在坐标系中是通过一条直线划分成符合要求的两块空间，（以真值表中四个点为例）异或门只能用曲线分开 也就是单层感知机无法分离非线性空间 ","date":"2023-11-28","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/:1:3","tags":[],"title":"学习记录(1)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"categories":["Deep Learning from Scratch 学习笔记"],"content":"多层感知机 python实现异或门 def AND(x1, x2): x = np.array([x1,x2]) #input w = np.array([0.5, 0.5]) #weight b = -0.7 #bias tmp = np.sum(w*x) + b if tmp \u003c= 0: return 0 else: return 1 def NAND(x1, x2): x = np.array([x1,x2]) #input w = np.array([-0.5, -0.5]) #weight b = 0.7 #bias tmp = np.sum(w*x) + b if tmp \u003c= 0: return 0 else: return 1 def OR(x1, x2): x = np.array([x1,x2]) #input w = np.array([0.5, 0.5]) #weight b = -0.2 #bias tmp = np.sum(w*x) + b if tmp \u003c= 0: return 0 else: return 1 def XOR(x1, x2): s1 = NAND(x1, x2) s2 = OR(x1, x2) return AND(s1, s2) print (\"0,0\", XOR(0,0)) print (\"1,0\", XOR(1,0)) print (\"0,1\", XOR(0,1)) print (\"1,1\", XOR(1,1)) 0,0 0 1,0 1 0,1 1 1,1 0 ","date":"2023-11-28","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/:1:4","tags":[],"title":"学习记录(1)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"categories":["Deep Learning from Scratch 学习笔记"],"content":"与非门至计算机 ","date":"2023-11-28","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/:1:5","tags":[],"title":"学习记录(1)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"categories":["Deep Learning from Scratch 学习笔记"],"content":"神经网络 ","date":"2023-11-28","objectID":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/:2:0","tags":[],"title":"学习记录(1)","uri":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"},{"categories":["vscode配置"],"content":"通过vscode的remote-ssh插件可以在vscode上远程登陆服务器，登录和打开工作文件夹时都需要输入密码，可以通过配置ssh免密登录，使登录和使用更加丝滑 ","date":"2023-11-20","objectID":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/:0:0","tags":[],"title":"Vscode密钥远程连接","uri":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["vscode配置"],"content":"必要软件安装 ssh-keygen 和 ssh-copy-id 安装，window电脑powershell中这两个命令已内置 ","date":"2023-11-20","objectID":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/:1:0","tags":[],"title":"Vscode密钥远程连接","uri":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["vscode配置"],"content":"ssh-keygen配置密钥对 配置密钥 PS C:\\Users\\griedzx\u003e ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (C:\\Users\\griedzx/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in C:\\Users\\griedzx/.ssh/id_rsa Your public key has been saved in C:\\Users\\griedzx/.ssh/id_rsa.pub The key fingerprint is: SHA256:sYURFrXR+/Xffdy+HmOSu1yxPCH8WbXcoKNvSZF4RDQ griedzx@dzx_pc The key's randomart image is: +---[RSA 3072]----+ | =+o+E | | . o oo. | | o oo o. .| | +. *...=| | S .o= *+| | ...* B| | .. + %=| | .+ = @| | ..+o++| +----[SHA256]-----+ 注意 Enter passphrase (empty for no passphrase): 不输入密码，直接回车继续，否则之前对应输入服务器用户密码的地方变成了密钥对的密码 ssh-keygen常用参数 ssh-keygen -t: 密钥类型, 可以选择 dsa | ecdsa | ed25519 | rsa; -f: 密钥目录位置, 默认为当前用户home路径下的.ssh隐藏目录, 也就是~/.ssh/, 同时默认密钥文件名以id_rsa开头. 如果是root用户, 则在/root/.ssh/id_rsa, 若为其他用户, 则在/home/username/.ssh/id_rsa; -C: 指定此密钥的备注信息, 需要配置多个免密登录时, 建议携带; -N: 指定此密钥对的密码, 如果指定此参数, 则命令执行过程中就不会出现交互确认密码的信息了. 设定目录下会出现密钥对文件：id_rsa.pub是公钥 id_rsa是私钥 ","date":"2023-11-20","objectID":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/:2:0","tags":[],"title":"Vscode密钥远程连接","uri":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["vscode配置"],"content":"公钥传输至服务器 公钥放server(远程主机)上，私钥放本机上 ","date":"2023-11-20","objectID":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/:3:0","tags":[],"title":"Vscode密钥远程连接","uri":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["vscode配置"],"content":"代码传输 公钥配置至服务器上（Window -\u003e Linux） $USER_AT_HOST = \"yh@760755rf68.imdo.co\" #id@ip $PUBKEYPATH = \"$HOME/.ssh/id_rsa.pub\" $pubKey = (Get-Content \"$PUBKEYPATH\"|Out-string); ssh -p 37763 \"$USER_AT_HOST\" \"echo '${pubKey}' \u003e\u003e ~/.ssh/authorized_keys\" ","date":"2023-11-20","objectID":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/:3:1","tags":[],"title":"Vscode密钥远程连接","uri":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["vscode配置"],"content":"简单粗暴的方法 建议直接cat 本地的id_rsa.pub PS C:\\Users\\griedzx\\.ssh\u003e cat id_rsa.pub 然后复制内容到服务器的~/.ssh/authorized_keys中新增一行 #服务器端 (base) yh@localhost 21:21:38 ~/.ssh $ vim authorized_keys ","date":"2023-11-20","objectID":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/:3:2","tags":[],"title":"Vscode密钥远程连接","uri":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["vscode配置"],"content":"修改$home/.ssh/config 修改.ssh/config文件：加入IdentityFile的路径（也就是私钥在本机的所在位置） Host yh_xw HostName 760755rf68.imdo.co Port 37763 User yh IdentityFile \"C:\\Users\\griedzx\\.ssh\\id_rsa\" vscode登录server就不用输入密码了 ","date":"2023-11-20","objectID":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/:4:0","tags":[],"title":"Vscode密钥远程连接","uri":"/vscode%E5%AF%86%E9%92%A5%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"categories":[],"content":"2023.11.10 好多事压得喘不过气，以致于感叹时间不够用，希望一个良好的睡眠可以解决一些些压力🙏 ","date":"2023-11-10","objectID":"/dairy/:0:0","tags":[],"title":"Dairy","uri":"/dairy/"},{"categories":["本科项目育人"],"content":"项目介绍 植物的自交不亲和性有许多原因，其中本项目所关注的异型花柱是其中之一，这种花的多态性结构至少出现在28个被子植物科中，准备搜集研究其中公共数据库中已有相关植物的基因组，对这些植物的基因组进行比较分析、共线性分析等，其中特别关注比较s位点上的超基因，去研究这些植物自交不亲和的差异以及相似性，帮助理解这些植物基因组的演化关系，以及s位点上的超基因的演化动态。 基因组比较 ：接下来，可以使用synteny、mcscan、mummer等软件工具，对这些植物的基因组进行比较分析。可以通过比较s位点上的超基因，来研究这些植物自交不亲和性的差异和相似性。 共线性分析 ：在基因组比较的基础上，还可以进行共线性分析。这将帮助你理解这些植物基因组的演化关系，以及s位点上超基因的演化动态。 ","date":"2023-11-03","objectID":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":[],"title":"项目育人初体验","uri":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["本科项目育人"],"content":"自交不亲和性（SI）Self-incompatibility 概念 指具有 完全花并可以形成正常雌、雄配子，但缺乏自花授粉结实能力的一种自交不育性。 完全花概述图 陆地生物占地球生物总数的85%，其多样性与被子植物的起源和扩张密切相关。被子植物约有20多万种，是植物界最大的类群，但其形成和扩张的原因仍为未解之谜。现存被子植物中，约40%具有自交不亲和性 (Self-incompatibility, SI)。SI是一种正常可育的雌雄同花被子植物自花授粉后不能产生合子的现象，对于促进其异交并增加其多样性至关重要。 ","date":"2023-11-03","objectID":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/:1:1","tags":[],"title":"项目育人初体验","uri":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["本科项目育人"],"content":"异型花柱(heterostyly) 根据推文：武汉植物园在植物异型花柱分子遗传调控机制研究中取得新进展所说 具有异型花柱的物种通常同时具有自交不亲和机制 异型花柱在被子植物中广泛分布，已在28个科中被报道 异型花柱在遗传上是由S位点（一个超基因，由多个紧密连锁的基因组成，这些基因分别控制花柱长度或雄蕊高度等特征）决定的 概念 异型花柱是著名的花的多态性现象之一，表现为雌蕊与雄蕊的高度交互匹配，即交互式雌雄异位。雌蕊（花的雌性部分）和雄蕊（花的雄性部分）的长度和位置能够精确地匹配，以便在传粉过程中，雄蕊能够将花粉准确地传递到雌蕊上。 插一个很有意思的科普推文 上下三百年：“花柱异长”是怎么被发现的？| 果壳 科技有意思 (guokr.com) 从这篇推文的描述中看，似乎这个雌蕊与雄蕊的高度交互匹配，是长柱花的雌蕊和短柱花的雄蕊（或者相反）交互匹配，这样也导致花粉不同类型之间传播，而相同类型则断绝了传播，从而既不浪费又阻止了近亲繁殖。 有效传粉者长期缺乏时异型花柱植物可能的演化趋势。 由于基因突变以及生物因子（如传粉者）和非生物因子的共同作用，有时异型花柱多态性结构难以稳定维持，在群体间和群体内产生极大变异，最终促进植物交配系统的多样性演化,如上图所示。 趋同进化 研究发现，植物花柱异长独立演化超过了20次，这个复杂的多态现象已经成为了趋同进化的经典案例。 对于趋同进化，最符合我们常识的是，植物界中，很多亲缘关系甚远的物种会在自然选择作用下表现出趋同进化现象，例如生活在干旱沙漠环境中的植物往往叶片退化成针状，高山植物大多矮化成垫状等。 在异型花柱这个性状中，自然环境带来的压力（想要成功繁殖，不同花型的植株之间需要匹配的花型以接收相同高度的繁殖器官之间的花粉流），使得一种花型的雄性和互补花型的雌性适合度得到增强，这样一来，选择压力会使得花柱异长的植物性别专化。 我们要研究是在目前发现的异型花柱的形态趋同进化的背后是否隐藏着分子水平的趋同进化。 ","date":"2023-11-03","objectID":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/:1:2","tags":[],"title":"项目育人初体验","uri":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["本科项目育人"],"content":"S位点（S-locus） 自交不亲和这一复杂性状由一个高多态性超基因S位点控制。 概念 s位点是一种遗传位点，通常由单一复等位且包含紧密连锁的雌性和雄性S基因的S位点控制。 其中，1类S位点常包含一个S-核酸酶和多个SLF，分别编码雌性和雄性自交不亲和决定因子 雌性S基因编码一个T2类核酸酶即S-核酸酶 雄性S基因则编码多个C端为FBK或FBA结构域的F-box蛋白SLF 异交授粉时，由于多个SLF可协同识别并解除异己S-核酸酶的细胞毒性，因而产生异交亲和反应；而在自交授粉时，自己S-核酸酶的毒性由于无法被抑制，最终产生自交不亲和反应。 即我自己的柱头不承认我自己的花粉，落上来也不理睬它，不允许它正常发育 超基因是由多个基因组成的一个遗传单元，这些基因通常紧密连锁在一起，以便在遗传上一起传递。异型花柱是一种由超基因控制的花形态结构的多样性， ","date":"2023-11-03","objectID":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/:1:3","tags":[],"title":"项目育人初体验","uri":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["本科项目育人"],"content":"武汉植物园在植物异型花柱分子遗传调控机制研究中取得新进展 推文解读 异型花柱的研究对象 ：水生植物 金银莲花 （Nymphoides indica），具有长、短柱花两种形态，由S位点决定。 基因组测序和关联分析 ：构建了高质量的 单倍型基因组 ，并通过全基因组关联分析发现了控制金银莲花异型花柱的 S位点超基因 ，鉴定并解析了金银莲花中S位点超基因的演化和功能，发现了三个S位点候选基因 - NinBAS1、NinKHZ2、NinS1。 S位点基因的功能和演化 ：研究团队探讨了S位点基因及其调控网络的潜在功能，以及转座元件和逐步基因复制对异型花柱超基因演化可能起到的作用。研究结果表明，油菜素内酯和PIF分子调控网络在金银莲花异型花柱的发育过程中具有重要的作用，为分子层面上异型花柱的趋同演化提供了进一步的证据。 ","date":"2023-11-03","objectID":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":[],"title":"项目育人初体验","uri":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["本科项目育人"],"content":"花柱异型的科名录 Ensembl Plants Ensembl植物数据库 花柱异型研究进展.pdf (book118.com) 在这篇2010年有关异型花柱的中文综述中提及为30多种 Comparative Genomics Elucidates the Origin of a Supergene Controlling Floral Heteromorphism - PubMed (nih.gov) A classic example of supergene is the S locus controlling heterostyly, a floral heteromorphism occurring in 28 angiosperm families. In Primula, heterostyly is characterized by the cooccurrence of two complementary, self-incompatible floral morphs and is controlled by five genes clustered in the hemizygous, ca. 300-kb S locus. 在这篇22年文章中 ‘A most complex marriage arrangement’: recent advances on heterostyly and unresolved questions (wiley.com) 针对下载的基因组 通过GFF/GTF文件评估基因组注释完整性 GFF（Generic Feature Format）, 描述了基因组上各种特征的区间信息，包括染色体，基因，转录本等。GFF文件 ‘\\t’分隔的纯文本文件。 检查GFF文件，若显示有exon和CDS信息，则基因组注释相对完全，可用于分析。如果既没有exon信息，也没有CDS信息，则基因组注释信息缺失，需要等注释信息完善后才可以用于有参转录组分析的参考基因组。 ","date":"2023-11-03","objectID":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":[],"title":"项目育人初体验","uri":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["本科项目育人"],"content":"参考 自交不亲和性_百度百科 (baidu.com) 被子植物自交不亲和性起源、丢失和重获的高度动态进化机制 (baidu.com) 华南植物园等在异型花柱植物的交配多样性演化研究中获进展—-中国科学院 (cas.cn) 武汉植物园在植物异型花柱分子遗传调控机制研究中取得新进展 (qq.com) 上下三百年：“花柱异长”是怎么被发现的？| 果壳 科技有意思 (guokr.com) 科学驿站｜最新研究：基因水平的趋同进化推动植物形态上的趋同进化_腾讯新闻 (qq.com) 中科院薛勇彪研究组合作揭示金鱼草基因组S位点超基因的动态演化机制 - 知乎 (zhihu.com) 遗传发育所等揭示被子植物自交不亲和性起源、丢失和重获的高度动态进化机制—-中国科学院 (cas.cn) 花柱异型研究进展.pdf (book118.com) ","date":"2023-11-03","objectID":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/:4:0","tags":[],"title":"项目育人初体验","uri":"/%E9%A1%B9%E7%9B%AE%E8%82%B2%E4%BA%BA%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":[],"content":"解决github打不开的方法（亲测有效） - 知乎 (zhihu.com) IP/服务器github.com的信息 - 站长工具 (chinaz.com) IP/服务器github.global.ssl.fastly.net的信息 - 站长工具 (chinaz.com) ","date":"2023-10-28","objectID":"/github_network_err/:0:0","tags":[],"title":"Github_network_err","uri":"/github_network_err/"},{"categories":["表观组学"],"content":"使用deeptools的 computeMatrix + (plotHeatmap or plotProfile)可以针对某些特定类型的区域如TTS、TES的指定区域范围进行信号富集程度的可视化 ","date":"2023-10-20","objectID":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/:0:0","tags":["computeMatrix"],"title":"甲基化+组蛋白测序heatmap+profile绘制","uri":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/"},{"categories":["表观组学"],"content":"computeMatrix’s parameters computeMatrix提供两个不同参数（parameters）以指定不同的参考系 Commands: scale-regions In the scale-regions mode, all regions in the BED file are stretched or shrunken to the length (in bases) indicated by the user. reference-point Reference-point refers to a position within a BED region (e.g., the starting point). In this mode, only those genomicpositions before (upstream) and/or after (downstream) of the reference point will be plotted. 对于reference-point，只指定一个参考点(TTS,TES,center),因此对于基因组区域文件 \u003cbed file(s)\u003e,不会对不同基因均一化，直接使用指定上游或者下游一段距离 对应scale-region,会均一化基因长度,使得不同基因TSS至TES之间区域长度一致。 --regionBodyLength REGIONBODYLENGTH, -m REGIONBODYLENGTH Distance in bases to which all regions will be fit. (Default: 1000) --binSize BINSIZE, -bs BINSIZE Length, in bases, of the non-overlapping bins for averaging the score over the regions length. (Default: 10) 在众多参数中，computeMatrix通过 regionBodyLength和 binSize来确定将不同基因分成相同分数的bin长度，使得基因长度均一化。 默认参数中 regionBodyLength=1000 binSize=10，因此份数为1000/10=100，也就是将不同的基因统一切成100块，每一块参数对应一段bin内所有信号加和除以bin长度的平均值。 ","date":"2023-10-20","objectID":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/:1:0","tags":["computeMatrix"],"title":"甲基化+组蛋白测序heatmap+profile绘制","uri":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/"},{"categories":["表观组学"],"content":"对不同组蛋白_ChIP-seq测序数据画图 针对与不同的目的蛋白结合的 DNA 片段进行测序数据，我们可以一次性输入多个对应的bigwig文件画成一张图。 具体代码: bed=/home/ljx/yuanh/work_data/Ref_genome/220721_Maize_B73_V4/Maize_gene_1-10_chr.bed for org_path in /home/yuanhx/dzx/230612_encher_data/0*; do org=$(basename $org_path | sed 's/^...//') bw_files=\"\" for bw_id in $org_path/result/0*/bam/*bigwig; do bw_files=\"$bw_files $bw_id\" done computeMatrix scale-regions -p 10 \\ -b 2000 -a 2000 \\ -R $bed \\ -S $bw_files \\ --missingDataAsZero \\ --skipZeros -o $org_path/result/matrix_${org}_2K.gz plotHeatmap -m $org_path/result/matrix_${org}_2K.gz \\ -out /home/yuanhx/dzx/230612_encher_data/${org}_Heatmap_2K.png done ","date":"2023-10-20","objectID":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/:2:0","tags":["computeMatrix"],"title":"甲基化+组蛋白测序heatmap+profile绘制","uri":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/"},{"categories":["表观组学"],"content":"对甲基化测序数据画图 初始数据处理 $ head -100 output-prefix.bsmap.mkdup_CHG.bedGraph track type=\"bedGraph\" description=\"output-prefix.bsmap.mkdup CHG methylation levels\" 1 1472 1473 100 9 0 1 1474 1475 90 311 34 1 1533 1534 75 6 2 1 1535 1536 69 99 43 1 1562 1563 33 3 6 1 1581 1582 37 3 5 1 1654 1655 50 2 2 1 1712 1713 75 9 3 1 1714 1715 100 3 0 直接使用原始bedGraph数据通过 bedGraphToBigwig 转换成bigwig文件画图，missingdata过多，热图黑色部分贼多 人工分bin，将1号染色体的最开始片段位置初始化0，按照100bp分段，对应的四列数据百分比处理 最后处理后的格式如下： 画图代码： bed=\"/home/ljx/yuanh/work_data/Ref_genome/220721_Maize_B73_V4/Maize_gene_1-10_chr.bed\" for id in /home/yh/dzx/work/231017_methylation/methylation_bigwig_data/*;do org=`echo $id | cut -d '/' -f 8` echo \"org:$org\" bigwig_files=`ls $id/*.bigwig` echo -e \"bigwig_files:\\n$bigwig_files\" computeMatrix scale-regions -p 10 \\ -b 2000 -a 2000 \\ -R $bed \\ -S $bigwig_files \\ --missingDataAsZero \\ --skipZeros -o /home/yh/dzx/work/231017_methylation/matrix/$org/matrix.gz echo \"$org matrix.gz done\" plotHeatmap -m /home/yh/dzx/work/231017_methylation/matrix/$org/matrix.gz \\ -out /home/yh/dzx/work/231017_methylation/plotHeatmap/$org/${org}_Heatmap_2K.pdf echo \"$org heatmap done\" done 甲基化热图 ","date":"2023-10-20","objectID":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/:3:0","tags":["computeMatrix"],"title":"甲基化+组蛋白测序heatmap+profile绘制","uri":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/"},{"categories":["表观组学"],"content":"分表达水平高低绘制信号富集谱图 给基因区域bed文件赋值基因表达数据,将表达数据赋值至最后一列 gene_bed \u003c- read.table(\"gene_length.bed\", header = F, sep = \"\\t\", stringsAsFactors = F) exp_data_1 \u003c- read.csv(\"/home/yuanhx/dzx/work_data/exp_data/lai_py_expressed.csv\", header = T) exp_data_2 \u003c- read.csv(\"/home/yuanhx/dzx/work_data/exp_data/yang_ear_tassel.csv\", header = T) gene_bed$V6 \u003c- sub(\"ID=gene:\", \"\", gene_bed$V6) exp_data_1$tracking_id \u003c- as.character(exp_data_1$tracking_id) exp_data_2$tracking_id \u003c- as.character(exp_data_2$tracking_id) orgs \u003c- c(\"ear_1\", \"ear_2\", \"shoot_1\", \"shoot_2\", \"tassel\") for (org in orgs){ for (i in 1:nrow(gene_bed)){ if(org %in% c(\"ear_1\", \"shoot_1\",\"shoot_2\")){ if(gene_bed$V6[i] %in% exp_data_1$tracking_id == F){ gene_bed$V8[i] \u003c- \"not_found\" next } if(org %in% c(\"ear_1\", \"shoot_1\")){ gene_bed$V8[i] \u003c- exp_data_1[which(exp_data_1$tracking_id == gene_bed$V6[i]), paste0(\"average.\",sub(\"..$\",\"\",org))] } else if(org == \"shoot_2\"){ gene_bed$V8[i] \u003c- exp_data_1[which(exp_data_1$tracking_id == gene_bed$V6[i]), paste0(sub(\"..$\",\"\",org),\".average\")] } } else{ if(gene_bed$V6[i] %in% exp_data_2$tracking_id == F){ gene_bed$V8[i] \u003c- \"not_found\" next } if(org == \"ear_2\") org = \"ear\" gene_bed$V8[i] \u003c- exp_data_2[which(exp_data_2$tracking_id == gene_bed$V6[i]), paste0(\"average.\",org)] org = \"ear_2\" } } write.table(gene_bed, file.path(org, paste0(org, \"_gene_exp\",\".bed\")), row.names = F, col.names = F, sep = \"\\t\") } 做实验的提供的表达量数据格式真的是个无敌复杂，而且总是多次用到，应该找个时间优化一下格式 根据表达量切分bed文件 #!/bin/bash data_dir=\"/home/yuanhx/dzx/org_gene_bed/\" for subdir in ear_1 ear_2 shoot_1 shoot_2 tassel; do echo \"处理子目录: $subdir\" cd \"$data_dir$subdir\" gene_exp_file=*gene_exp.bed # 对文件按照表达量排序 sort -k 8,8n $gene_exp_file \u003e sorted_gene_exp.bed split -d -n l/7 sorted_gene_exp.bed split_ for ((i=0; i\u003c7; i++)); do mv \"split_0$i\" \"part$i.bed\" done echo \"处理完成: $gene_exp_file\" cd \"$data_dir\" done 处理后文件存放格式如此 画图 for id in /home/yuanhx/dzx/230612_encher_data/0*/result/0*/bam/*bigwig; do org=$(echo $id | awk -F'/' '{print $6}' | cut -c4-) bed_files=\"\" for bed_id in /home/yuanhx/dzx/org_gene_bed/$org/part*.bed; do bed_files=\"$bed_files $bed_id\" done out_path=$(echo $id | cut -d'/' -f1-8) seq_name=$(basename $id | cut -d'.' -f1) computeMatrix scale-regions -p 11 \\ -b 2000 -a 2000 \\ -R $bed_files \\ -S $id \\ --missingDataAsZero \\ --skipZeros -o $out_path/matrix/${seq_name}_2k.gz plotProfile -m $out_path/matrix/${seq_name}_2k.gz -out $out_path/matrix/${seq_name}_Profile_2K.png done -S bigwig文件 -R bed文件可以分别传入多个 ","date":"2023-10-20","objectID":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/:4:0","tags":["computeMatrix"],"title":"甲基化+组蛋白测序heatmap+profile绘制","uri":"/%E7%94%B2%E5%9F%BA%E5%8C%96-%E7%BB%84%E8%9B%8B%E7%99%BD%E6%B5%8B%E5%BA%8Fheatmap-profile%E7%BB%98%E5%88%B6/"},{"categories":["生物文本挖掘"],"content":"TF-IDF简要介绍 TF-IDF(term frequency–inverse document frequency)，一种常用于挖掘文章中关键词的加权技术。某个词在文章（一篇文章或者某类文章）中的TF-IDF越大，那么一般而言这个词在这篇文章的重要性会越高 ，可以作为其一个特征 TF-IDF(词频-逆文档频率)=TF * IDF ","date":"2023-10-18","objectID":"/tf-idf/:1:0","tags":[],"title":"TF-IDF","uri":"/tf-idf/"},{"categories":["生物文本挖掘"],"content":"词频（TF） 表示词条（关键字）在文本中出现的频率 ,通常会被归一化(一般是词频除以文章总词数)。 上述没有统一标准化词频，用来展现特定主题文章下特定词语出现的次数。 ","date":"2023-10-18","objectID":"/tf-idf/:1:1","tags":[],"title":"TF-IDF","uri":"/tf-idf/"},{"categories":["生物文本挖掘"],"content":"逆文档频率 (IDF) 某一特定词语的IDF，可以由 总文件数目除以包含该词语的文件的数目 ， 再将得到的商取对数得到 。 ","date":"2023-10-18","objectID":"/tf-idf/:1:2","tags":[],"title":"TF-IDF","uri":"/tf-idf/"},{"categories":["生物文本挖掘"],"content":"TF-IDF计算的伪代码 # 定义文档集合 documents = [...] # 计算词频TF def computeTF(wordDict, doc): tfDict = {} corpusCount = len(doc) for word, count in wordDict.items(): tfDict[word] = count / float(corpusCount) return tfDict # 计算逆文档频率IDF def computeIDF(docList): import math idfDict = {} N = len(docList) idfDict = dict.fromkeys(docList[0].keys(), 0) for doc in docList: for word, val in doc.items(): if val \u003e 0: idfDict[word] += 1 for word, val in idfDict.items(): idfDict[word] = math.log10(N / float(val)) return idfDict # 计算TF-IDF def computeTFIDF(tfBagOfWords, idfs): tfidf = {} for word, val in tfBagOfWords.items(): tfidf[word] = val * idfs[word] return tfidf ","date":"2023-10-18","objectID":"/tf-idf/:2:0","tags":[],"title":"TF-IDF","uri":"/tf-idf/"},{"categories":["生物文本挖掘"],"content":"NLTK实现TF-IDF计算 from nltk.text import TextCollection from nltk.tokenize import word_tokenize #首先，构建语料库corpus sents=['this is sentence one','this is sentence two','this is sentence three'] sents=[word_tokenize(sent) for sent in sents] #对每个句子进行分词 print(sents) #输出分词后的结果 corpus=TextCollection(sents) #构建语料库 print(corpus) #输出语料库 #计算语料库中\"one\"的tf值 tf=corpus.tf('one',corpus) # 1/12 print(tf) #计算语料库中\"one\"的idf值 idf=corpus.idf('one') #log(3/1) print(idf) #计算语料库中\"one\"的tf-idf值 tf_idf=corpus.tf_idf('one',corpus) print(tf_idf) TextRank算法在新冠相关文献文本分析中的应用主要体现在以下几个方面： 关键词提取 ：TextRank算法可以用于从大量的新冠相关文献中提取关键词。这些关键词可以帮助研究者快速理解文本的主题，从而更有效地浏览和理解大量的文献。 文本摘要 ：TextRank算法也可以用于生成文本摘要。在处理新冠相关文献时，TextRank可以帮助我们快速识别出文本的主题，从而更有效地浏览和理解大量的文献。 信息检索 ：在信息检索中，TextRank算法可以用于评估文档的重要性，从而提高搜索引擎的效率。 知识图谱构建 ：在知识图谱构建中，TextRank算法可以用于从文本中提取实体和关系，从而构建知识图谱。 ","date":"2023-10-18","objectID":"/tf-idf/:3:0","tags":[],"title":"TF-IDF","uri":"/tf-idf/"},{"categories":["生物文本挖掘"],"content":"参考 Lexicon Computing 基本词汇计算 (wordpress.com) 盘点 KeyBert、TextRank 等九种主流关键词提取算法原理及 Python 代码实现 - 知乎 (zhihu.com) ","date":"2023-10-18","objectID":"/tf-idf/:4:0","tags":[],"title":"TF-IDF","uri":"/tf-idf/"},{"categories":["生物文本挖掘"],"content":"API调用 #! /bin/bash id_list='/home/yh/dzx/work/BioNLP/EntityAnnotation/pmid.txt' #读取id时跳过pmid.txt第一行列名 while read line do if [ $line != 'pmid' ] then curl https://www.ncbi.nlm.nih.gov/research/pubtator-api/publications/export/pubtator?pmids=$line \u003e\u003e /home/yh/dzx/work/BioNLP/EntityAnnotation/abstract_pubtator.txt echo \u003e\u003e /home/yh/dzx/work/BioNLP/EntityAnnotation/abstract_pubtator.txt fi sleep 2 done \u003c $id_list cat abstract_pubtator.txt|grep -v '|t|' |grep -v '|a|'|awk -F\"[[:space:]]+\" '{print $5}'|head ","date":"2023-10-17","objectID":"/pubtator/:1:0","tags":[],"title":"PubTator","uri":"/pubtator/"},{"categories":[],"content":" ifelse(test, yes, no) all \u003c- inter_data %\u003e% filter(gene1 %in% tf_data | gene2 %in% tf_data) %\u003e% distinct() all$param_1 \u003c- ifelse(all$gene1 %in% tf_data, 1, 0) all$param_2 \u003c- ifelse(all$gene2 %in% tf_data, 2, 0) all$sum \u003c- all$param_1 + all$param_2 inter_data \u003c- all %\u003e% filter(sum != 0) write.csv(all, \"e:/1/TF_inter.csv\", row.names = FALSE) write.csv(inter_data, \"e:/1/TF_inter.1.0.csv\", row.names = FALSE) library(dplyr) inter_data \u003c- read.csv(\"E:/1/ear_1.csv\", header = FALSE, sep = \",\") %\u003e% select(1,5) %\u003e% mutate(param_1 = 0, param_2 = 0, sum = 0) %\u003e% rename(gene1 = V1, gene2 = V5) TF \u003c- read.csv(\"e:/1/TF_summary.csv\", header = TRUE, sep = \",\") tf_data \u003c- TF$TF_zong all_1 \u003c- inter_data %\u003e% filter(inter_data$gene1 %in% tf_data) all_2 \u003c- inter_data %\u003e% filter(inter_data$gene2 %in% tf_data) all \u003c- rbind(all_1, all_2) %\u003e% distinct() write.csv(all, \"e:/1/TF_inter.csv\", row.names = FALSE) for(i in 1:nrow(inter_data)){ if(inter_data$gene1[i] %in% tf_data){ inter_data$param_1[i] \u003c- 1 } if(inter_data$gene2[i] %in% tf_data){ inter_data$param_2[i] \u003c- 2 } inter_data$sum[i] \u003c- inter_data$param_1[i] + inter_data$param_2[i] } inter_data \u003c- inter_data %\u003e% filter(inter_data$sum != 0) write.csv(inter_data, \"e:/1/TF_inter.1.0.csv\", row.names = FALSE) #两列同时存在的 same \u003c- inter_data %\u003e% filter(inter_data$gene1 %in% tf_data \u0026 inter_data$gene2 %in% tf_data) write.csv(same, \"e:/1/TF_same.csv\", row.names = FALSE) ","date":"2023-10-09","objectID":"/r%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02/:0:0","tags":[],"title":"R语言笔记2","uri":"/r%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B02/"},{"categories":["处理和分析高通量测序数据"],"content":"利用ChIPseeker R包对peak进行注释 经过前期的处理拿到了BED文件，利用这些文件和ChIPSeeker可以进一步对peak注释、可视化。 ","date":"2023-10-08","objectID":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/:0:0","tags":["peak注释"],"title":"R包peak注释","uri":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/"},{"categories":["处理和分析高通量测序数据"],"content":"指定Bioregion结合图谱可视化 网上大部分教程都是限定一个固定的窗口(比如最常用到的TSS启动子区域)，将所有的peak全部align(标准化对齐？)，可视化其结合谱图。而我想要的效果是 将**整个基因(从TSS上游限定部分至TTS下游限定部分)**作为一个窗口 类似效果如下图左侧的 original regions scaled to the same length deeptools示例 经过一系列bing搜索找到了这个问题的解决顺寻： could the \"plotAvgProf\" can get the region from TSS to TTS ? · Issue #87 · YuLab-SMU/ChIPseeker · GitHu Adding function of plotting bioregion by binning by MingLi-929 · Pull Request #156 · YuLab-SMU/ChIPseeker (github.com) Adding function of plotting bioregion by binning #156 在这个界面中，作者借鉴deeptools中computeMatrix的分bin方法归一化不同BioRegion的长度，加入了一系列函数实现上述设想目的。 但是实践后发现在最新的包里面似乎没有了这些函数，最后在bioconductor中找到一些详细的示例说明，发现函数名称功能重整。 ChIPseeker: an R package for ChIP peak Annotation, Comparison and Visualization (bioconductor.org) plotPeakProf2示例 plotPeakProf2，可以直接输入*summits.bed文件名（路径），通过指定 type = \"body\"将txdb文件中每一条序列的整个特定BioRegion作为一个窗口。 ","date":"2023-10-08","objectID":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/:1:0","tags":["peak注释"],"title":"R包peak注释","uri":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/"},{"categories":["处理和分析高通量测序数据"],"content":"实践流程 \u0026 代码 导入相关的包 library(ChIPseeker) #install.packages(\"RMariaDB\") library(RMariaDB) library(GenomicFeatures) library(ggimage) 获取背景注释信息 GenomicFeatures包中有函数用来制作TxDb对象： makeTxDbFromUCSC： 通过UCSC在线制作TxDb makeTxDbFromBiomart: 通过ensembl在线制作TxDb makeTxDbFromGRanges：通过GRanges对象制作TxDb makeTxDbFromGFF：通过解析GFF文件制作TxDb 通过ucsc或者ensembl数据库ftp协议下载gff文件，如 ftp://ftp.ebi.ac.uk/pub/databases/pombase/pombe/Chromosome_Dumps/gff3/schiz maize_TxDb \u003c- makeTxDbFromGFF(\"E:/seq_project/work_data/Zma_B73_V4.gff3\") 整段peak注释画图代码 bed_data_path \u003c- \"E:/seq_project/work_data/summits_bed\" orgs \u003c- c(\"ear_1\", \"ear_2\", \"shoot_1\", \"shoot_2\", \"tassel\") plot_path \u003c- \"E:/seq_project/R包peak注释/plot\" for (org in orgs){ bed_files \u003c- list.files(paste(bed_data_path, org, sep = \"/\"), pattern = \"\\\\.bed$\", full.names = TRUE) bed_names \u003c- gsub(\"_summits.*\", \"\", basename(bed_files)) names(bed_files) \u003c- bed_names bed_files \u003c- as.list(bed_files) #依次读取bed文件 for (bed_file in bed_files){ peak \u003c- readPeakFile(bed_file) peakAnno \u003c- annotatePeak(peak, tssRegion=c(-2000, 2000), TxDb=maize_TxDb) pdf(file = file.path(plot_path,\"pie\", org, paste(basename(bed_file), \"_pie\", \".pdf\", sep = \"\"))) plotAnnoPie(peakAnno) dev.off() pdf(file = file.path(plot_path,\"pie\", org, paste(basename(bed_file), \"_upset\", \".pdf\", sep = \"\"))) p \u003c- upsetplot(peakAnno, vennpie=TRUE) print(p) dev.off() } pdf(file = file.path(plot_path,\"PeakProf\", paste0(org, \"genebody_PeakProf\", \".pdf\"))) p_1 \u003c- plotPeakProf2(bed_files, upstream = 1000, downstream = 1000, conf = 0.95, by = \"gene\", type = \"body\", nbin = 800, TxDb = maize_TxDb, facet = \"row\") print(p_1) dev.off() } ","date":"2023-10-08","objectID":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/:2:0","tags":["peak注释"],"title":"R包peak注释","uri":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/"},{"categories":["处理和分析高通量测序数据"],"content":"其他常规可视化 CS6: ChIP数据可视化 (guangchuangyu.github.io) ","date":"2023-10-08","objectID":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/:3:0","tags":["peak注释"],"title":"R包peak注释","uri":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/"},{"categories":["处理和分析高通量测序数据"],"content":"参考 CS6: ChIP数据可视化 (guangchuangyu.github.io) CS4：关于ChIPseq注释的几个问题 (qq.com) ChIPseeker: an R package for ChIP peak Annotation, Comparison and Visualization (bioconductor.org) ","date":"2023-10-08","objectID":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/:4:0","tags":["peak注释"],"title":"R包peak注释","uri":"/r%E5%8C%85peak%E6%B3%A8%E9%87%8A/"},{"categories":["处理和分析高通量测序数据"],"content":"ATAC-seq数据peak calling ","date":"2023-10-07","objectID":"/atac-seq/:1:0","tags":["ATAC-Seq"],"title":"ATAC-Seq数据处理","uri":"/atac-seq/"},{"categories":["处理和分析高通量测序数据"],"content":"fastq数据trim_galore软件质控 对双端测序的左右端结果文件进行处理 $ pwd /home/yuanhx/dzx/ATAC_seq/clean #shell脚本 bin_trim_galore=\"trim_galore\" ls ../raw/*gz | while read -r fq1 \u0026\u0026 read -r fq2; do $bin_trim_galore -q 10 --phred33 --length 35 -e 0.1 --stringency 4 --paired -o ./ $fq1 $fq2 done ","date":"2023-10-07","objectID":"/atac-seq/:1:1","tags":["ATAC-Seq"],"title":"ATAC-Seq数据处理","uri":"/atac-seq/"},{"categories":["处理和分析高通量测序数据"],"content":"bowtie2比对 用bowtie2进行比对和统计比对率,需要提前下载参考基因组然后使用命令构建索引，或者直接就下载索引文件： 这里使用下载好的参考基因组构建索引： $ pwd /home/ljx/yuanh/work_data/230926_Wheat_Ref_genome/index bowtie2-build --threads 25 ../Wheat_Ref_genome.fasta ./Wheat 双端测序数据的比对： cd /home/yuanhx/dzx/ATAC_seq/align bin_bowtie2='/home/ljx/yuanh/bin/bowtie2' bin_samtools='/home/ljx/yuanh/bin/samtools' index=\"/home/ljx/yuanh/work_data/230926_Wheat_Ref_genome/index/Wheat\" ls ../clean/*gz |while read -r fq1 \u0026\u0026 read -r fq2; do sample=$(basename $fq1 | cut -d '_' -f1) $bin_bowtie2 -p 10 -X 1000 -x $index -1 $fq1 -2 $fq2 |$bin_samtools sort -O bam -@ 20 -o -\u003e${sample}.bam done #slurm提交脚本 #!/bin/bash #SBATCH -J dzx #SBATCH -p GPU-3090-1 #SBATCH -N 1 #SBATCH -o /home/yuanhx/dzx/ATAC_seq/align/out.txt #SBATCH -e /home/yuanhx/dzx/ATAC_seq/align/err.txt # 记录开始时间 start_time=$(date +\"%Y-%m-%d %H:%M:%S\") echo \"Job started at $start_time\" # 运行任务 bash run.sh # 记录结束时间 end_time=$(date +\"%Y-%m-%d %H:%M:%S\") echo \"Job finished at $end_time\" # 计算运行时间 start_seconds=$(date -d \"$start_time\" +%s) end_seconds=$(date -d \"$end_time\" +%s) runtime=$((end_seconds - start_seconds)) echo \"Job took $runtime seconds to complete\" 对bam文件过滤 mkdir /home/yuanhx/dzx/ATAC_seq/mark_duplicate; cd $_ bin_picard='/home/ljx/yuanh/bin/picard' bin_samtools='/home/ljx/yuanh/bin/samtools' #去除PCR重复 ls ../clean/*gz |while read -r fq1 \u0026\u0026 read -r fq2; do sample=$(basename $fq1 | cut -d '_' -f1) java -jar /home/ljx/yuanh/software/picard.jar MarkDuplicates -I ../align/${sample}.bam \\ -O ${sample}.rmdup.bam -M ${sample}.rmdup.metric --REMOVE_DUPLICATES true #去除低质量reads(-q 30)以及未必对到同一条染色体(-f 2)的数据 $samtools view -h -f 2 -q 30 ${sample}.rmdup.bam | grep -v chrM | $samtools sort -O bam -@ 20 -o - \u003e${sample}.last.bam bedtools bamtobed -i ${sample}.last.bam \u003e${sample}.last.bed done ","date":"2023-10-07","objectID":"/atac-seq/:1:2","tags":["ATAC-Seq"],"title":"ATAC-Seq数据处理","uri":"/atac-seq/"},{"categories":["处理和分析高通量测序数据"],"content":"MACS2进行call peak cd /home/yuanhx/dzx/ATAC_seq/mark_duplicate ls *.bed | while read id; do macs2 callpeak -t $id -g 14300719022 --nomodel --shift -100 --extsize 200 -n ${id%%.*} --outdir ../peaks done 后续脚本整合 sbatch --dependency=afterok:21520 run.slurm run.slurm: #!/bin/bash #SBATCH -J dzx #SBATCH -p GPU-3090-1 #SBATCH -N 1 #SBATCH -o /home/yuanhx/dzx/ATAC_seq/out.txt #SBATCH -e /home/yuanhx/dzx/ATAC_seq/err.txt #SBATCH --mail-type=END #SBATCH --mail-user=2719323380@qq.com bash run.sh #run.sh mkdir /home/yuanhx/dzx/ATAC_seq/mark_duplicate; cd $_ picard='/home/ljx/yuanh/bin/picard' samtools='/home/ljx/yuanh/bin/samtools' #去除PCR重复 $picard MarkDuplicates -I ../align/${sample}.bam \\ -O ${sample}.rmdup.bam -M ${sample}.rmdup.metric --REMOVE_DUPLICATES true #去除低质量reads(-q 30)以及未必对到同一条染色体(-f 2)的数据 $samtools view -h -f 2 -q 30 ${sample}.rmdup.bam | grep -v chrM | $samtools sort -O bam -@ 20 -o - \u003e${sample}.last.bam bedtools bamtobed -i ${sample}.last.bam \u003e${sample}.last.bed cd /home/yuanhx/dzx/ATAC_seq/mark_duplicate ls *.bed | while read id; do macs2 callpeak -t $id -g 14300719022 --nomodel --shift -100 --extsize 200 -n ${id%%.*} --outdir ../peaks done ","date":"2023-10-07","objectID":"/atac-seq/:2:0","tags":["ATAC-Seq"],"title":"ATAC-Seq数据处理","uri":"/atac-seq/"},{"categories":["Perl"],"content":"运用实例 =pod 下列是一条蛋白质序列，请统计该序列长度、丙氨酸（A）的个数及所占的比例； MNAPERQPQPDGGDAPGHEPGGSPQDELDFSILFDYEYLNPNEEEPNAHKVASPPSGPAYPDDVLDYGLKPYSPLASLSGEPPGRFGEPDRVGPQKFLSAAKPAGASGLSPRIEITPSHELIQAVGPLRMRDAGLLVEQPPLAGVAASPRFTLPVPGFEGYREPLCLSPASSGSSASFISDTFSPYTSPCVSPNNGGPDDLCPQFQNIPAHYSPRTSPIMSPRTSLAEDSCLGRHSPVPRPASRSSSPGAKRRHSCAEALVALPPGASPQRSRSPSPQPSSHVAPQDHGSPAGYPPVAGSAVIMDALNSLATDSPCGIPPKMWKTSP =cut $protein_sequence = \"MNAPERQPQPDGGDAPGHEPGGSPQDELDFSILFDYEYLNPNEEEPNAHKVASPPSGPAYPDDVLDYGLKPYSPLASLSGEPPGRFGEPDRVGPQKFLSAAKPAGASGLSPRIEITPSHELIQAVGPLRMRDAGLLVEQPPLAGVAASPRFTLPVPGFEGYREPLCLSPASSGSSASFISDTFSPYTSPCVSPNNGGPDDLCPQFQNIPAHYSPRTSPIMSPRTSLAEDSCLGRHSPVPRPASRSSSPGAKRRHSCAEALVALPPGASPQRSRSPSPQPSSHVAPQDHGSPAGYPPVAGSAVIMDALNSLATDSPCGIPPKMWKTSP\"; $len = length($protein_sequence); $A_count = $protein_sequence =~ s/A/A/g; $A_per = ($A_count/$len)*100; print \"length: $len\\n\"; print \"the count of A: $A_count\\n\"; print \"the percentage of A: $A_per%\\n\"; ","date":"2023-09-19","objectID":"/perl_%E6%AD%A3%E5%88%99/:1:0","tags":["正则表达式","Perl"],"title":"perl中正则表达式","uri":"/perl_%E6%AD%A3%E5%88%99/"},{"categories":["Perl"],"content":"参考 Perl 正则表达式 | 菜鸟教程 (runoob.com) perl 统计字符串中特定字符出现的次数_ok_我的心的博客-CSDN博客 ","date":"2023-09-19","objectID":"/perl_%E6%AD%A3%E5%88%99/:2:0","tags":["正则表达式","Perl"],"title":"perl中正则表达式","uri":"/perl_%E6%AD%A3%E5%88%99/"},{"categories":["处理和分析高通量测序数据"],"content":"文件格式 BED (Browser Extensible Data),一种灵活的储存数据的格式，主要用来 储存基因组特征 （genomic features） 或注释信息(*.summits.bed) 。 BED格式可用于UCSC的Genome Browser可视化工具中 挖掘生物数据信息时，我们会将进行序列比对（未知的序列与已知的reference对比，从而找到未知序列中隐藏的信息），常见的序列比对的文件输出格式为sam和bam Sequence Alignment Mapping (SAM) 格式包括两部分：1. 注释信息（header section）2. 比对结果（alignment section） Binary Alignment/Map (BAM)是SAM格式的二进制压缩格式，这两种格式是序列比对时软件常用的数据格式 sam/bam格式文件，就是把测序reads比对到参考基因组后的文件 bam或者bed格式的文件主要是为了追踪我们的reads到底比对到了参加基因组的什么区域 ","date":"2023-09-12","objectID":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/:1:0","tags":["deeptools","生物信息常见文件格式"],"title":"deeptools_computeMatrix使用介绍","uri":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"categories":["处理和分析高通量测序数据"],"content":"deeptools功能 deeptools模块流程图 ","date":"2023-09-12","objectID":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/:2:0","tags":["deeptools","生物信息常见文件格式"],"title":"deeptools_computeMatrix使用介绍","uri":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"categories":["处理和分析高通量测序数据"],"content":"Deeptools 对 ChIP-seq 数据进行图形呈现 ","date":"2023-09-12","objectID":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/:3:0","tags":["deeptools","生物信息常见文件格式"],"title":"deeptools_computeMatrix使用介绍","uri":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"categories":["处理和分析高通量测序数据"],"content":"bam文件转换成bw文件格式 将bam文件转换为bigwig文件，这是一种压缩的二进制格式，可以快速加载和显示 bamCoverage -e 170 -bs 10 -b ap2_chip_rep1_2_sorted.bam -o ap2_chip_rep1_2.bw #ap2_chip_rep1_2_sorted.bam是前期比对得到的BAM文件 得到的bw文件就可以送去IGV/Jbro wse进行可视化。 这里的参数仅使用了 -e/--extendReads和 -bs/--binSize即拓展了原来的read长度，且设置分箱的大小。其他参数还有 --filterRNAstrand {forward, reverse}: 仅统计指定正链或负链 --region/-r CHR:START:END: 选取某个区域统计 --smoothLength: 通过使用分箱附近的read对分箱进行平滑化 如果为了其他结果进行比较，还需要进行标准化，deeptools提供了如下参数： --scaleFactor: 缩放系数 --normalizeUsingRPKMReads: Per Kilobase per Million mapped reads (RPKM)标准化 --normalizeTo1x: 按照1x测序深度(reads per genome coverage, RPGC)进行标准化 --ignoreForNormalization： 指定那些染色体不需要经过标准化 ","date":"2023-09-12","objectID":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/:3:1","tags":["deeptools","生物信息常见文件格式"],"title":"deeptools_computeMatrix使用介绍","uri":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"categories":["处理和分析高通量测序数据"],"content":"computeMatrix 计算每个基因组区域的得分，并生成一个可与 plotHeatmap 和 plotProfiles 一起使用的中间文件。 Required arguments: --regionsFileName File [File ...], -R File [File ...] File name or names, in BED or GTF format, containing the regions to plot. If multiple bed files are given, each one is considered a group that can be plotted separately. Also, adding a \"#\" symbol in the bed file causes all the regions until the previous \"#\" to be considered one group.(default: None) --scoreFileName File [File ...], -S File [File ...] bigWig file(s) containing the scores to be plotted. Multiple files should be separated by spaced. BigWig files can be obtained by using the bamCoverage or bamCompare tools. More information about the bigWig file format can be found at http://genome.ucsc.edu/goldenPath/help/bigWig.html(default: None) computeMatrix 有两种主要的使用模式/参数 computeMatrix reference-point reference-point 计算的基因组区域以某一个位置点作为相对参考点 --referencePoint {TSS,TES,center} region start (TSS) the region end(TES) the center of the region （默认为TSS） computeMatrix scale-regions scale-regions 计算的基因组区域为一段设定的区域长度（-b -a -m三个参数设置控制） #对单一样本绘图 computeMatrix scale-regions \\ -S shoot_ATAC-seq.bigwig \\ -R gene_length.bed \\ -b 1000 -a 1000 \\ -bs 50 \\ --skipZeros \\ -o matrix1_shoot_all.gz --outFileSortedRegions region1_shoot_genes.bed plotHeatmap -m matrix1_shoot_all.gz -out shoot_Heatmap.png ","date":"2023-09-12","objectID":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/:3:2","tags":["deeptools","生物信息常见文件格式"],"title":"deeptools_computeMatrix使用介绍","uri":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"categories":["处理和分析高通量测序数据"],"content":"参考 computeMatrix — deepTools 3.2.1 documentation (test-argparse-readoc.readthedocs.io) [生信资料 3] 生物信息学常见数据格式，汇总！ - 知乎 (zhihu.com) [软件使用05] 快速使用 Deeptools 对 ChIP-seq 数据画图！ - 知乎 (zhihu.com) ATAC-seq-TSS富集图-deeptools-学习笔记 - 知乎 (zhihu.com) ","date":"2023-09-12","objectID":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/:4:0","tags":["deeptools","生物信息常见文件格式"],"title":"deeptools_computeMatrix使用介绍","uri":"/deeptools_computematrix%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"},{"categories":["GSEA"],"content":"GSEA的结果图 GSEA的结果图通常包含三个部分 ","date":"2023-09-09","objectID":"/gsea_results/:1:0","tags":["ES折线图","信噪比"],"title":"GSEA结果理解","uri":"/gsea_results/"},{"categories":["GSEA"],"content":"富集分数（Enrichment Score）的折线图 横轴代表排序后的基因，纵轴为对应的Running ES。在折线图中出现的峰值就是这个基因集的富集分数（Enrichment Score，ES）。ES是从排序后的表达基因集的第一个基因开始，如果排序表达基因集中的基因出现在功能基因数据集中则加分，反之则减分。正值说明在顶部富集，峰值左边的基因为核心基因，负值则相反。 富集分数（ES） ES计算公式 正值ES表示基因 在功能注释基因集的顶部富集，负值ES表示基因 在功能注释基因集的底部富集。 ","date":"2023-09-09","objectID":"/gsea_results/:1:1","tags":["ES折线图","信噪比"],"title":"GSEA结果理解","uri":"/gsea_results/"},{"categories":["GSEA"],"content":"基因位置图 黑线代表排序后表达数据集中的基因存处于当前分析的功能注释基因集的位置 红蓝相间的热图是表达丰度排列，红色越深的表示该位置的基因logFC越大，蓝色越深表示logFC越小。如果研究的功能注释基因集的成员显著聚集在表达数据集的顶部或底部，则说明功能基因数据集中的基因在数据集中高表达或低表达，若随机分配，则说明表达数据集与该通路无关。 ","date":"2023-09-09","objectID":"/gsea_results/:1:2","tags":["ES折线图","信噪比"],"title":"GSEA结果理解","uri":"/gsea_results/"},{"categories":["GSEA"],"content":"信噪比（Signal2Noise） 每个基因对应的信噪比以灰色面积图显示。灰色阴影的面积比，可以从整体上反映组间的Signal2Noise的大小。 在GSEA（基因集富集分析）中，信噪比（Signal-to-Noise Ratio）是一种度量方法，用于对基因进行排序。这种排序方法是根据基因在两种样品中的差异表达程度或者表型相关度进行排序 具体来说，信噪比的计算方法如下： 信噪比的计算方法 首先，对所有基因按照它们在两种样品中的差异表达程度（如logFC）或者表型相关度进行排序。 然后，对于每一个基因，计算它在样品A中的平均表达量和样品B中的平均表达量的差值。这个差值就是该基因的信噪比。 在GSEA的结果展示图中，每个基因对应的信噪比以灰色面积图显示。灰色阴影的面积比，可以从整体上反映组间的Signal2Noise的大小。 GSEA图 在上图中，我们一般关注ES值，峰出现在排序基因集的前端还是后端（ES值大于0在前端，小于0在后端）以及 Leading edge subset（即对富集贡献最大的部分，领头亚集）；在ES图中出现领头亚集的形状，表明这个功能基因集在某处理条件下具有更显著的生物学意义。 ","date":"2023-09-09","objectID":"/gsea_results/:1:3","tags":["ES折线图","信噪比"],"title":"GSEA结果理解","uri":"/gsea_results/"},{"categories":["GSEA"],"content":"GSEA计算中几个关键概念 NES ：校正后的归一化的ES值 由于不同用户输入的基因数据库文件中的基因集数目可能不同，富集评分的标准化考虑了基因集个数和大小，其绝对值大于 1为一条富集标准。 FDR q-val：是多重假设检验校正之后的 p-value 即对 NES可能存在的假阳性结果的概率估计（多重假设检验校正 ：首先对每个基因子集 计算得到的ES根据基因集的大小进行标准化得到Normalized Enrichment Score (NES)。随后针对NES计算假阳性率） LEADING EDGE： 该处有3个统计值，tags=**%表示核心基因占该基因集中基因总数的百分比；list=**%表示核心基因占所有基因的百分比；signal=**%，将前两项统计数据结合在一起计算出的富集信号强度，计算公式如下： signal计算公式 核心基因：leading edge subset 指在该基因集中，对于富集结果的贡献最大的基因。 GSEA 对显著性的定义为 p-value\u003c5%，FDR q-val\u003c25% ","date":"2023-09-09","objectID":"/gsea_results/:1:4","tags":["ES折线图","信噪比"],"title":"GSEA结果理解","uri":"/gsea_results/"},{"categories":["GSEA"],"content":"参考 GSEA第2弹！如何解读GSEA富集结果 - 知乎 (zhihu.com) 史上最全GSEA可视化教程，今天让你彻底搞懂GSEA！ - 知乎 (zhihu.com) 一文掌握GSEA，超详细教程！ - 知乎 (zhihu.com) ","date":"2023-09-09","objectID":"/gsea_results/:2:0","tags":["ES折线图","信噪比"],"title":"GSEA结果理解","uri":"/gsea_results/"},{"categories":["GSEA"],"content":"GESA富集分析可以使用 java 版本的 GSEA软件进行富集。但是这个软件有一个问题就是自带的物种数据库有限（主要是人、小鼠的 PMT 文件、且不支持 KEGG 库），如果想要分析一些其他物种，需要上传自己准备的 PMT 文件。 这时候有一个可选的方案就是用 clusterProfiler包进行 GSEA 富集分析，该软件提供了两种方式进行富集： gseGO、gseKEGG等函数分别从 OrgDb、KEGG 官网读取或者下载 PMT 基因集 GSEA函数，一个通用的 GSEA 富集框架，支持从本地读取自己已经准备好的 PMT 基因集 ","date":"2023-08-29","objectID":"/clusterprofiler_gesa/:0:0","tags":["clusterProfiler","GESA"],"title":"clusterProfiler包GSEA富集","uri":"/clusterprofiler_gesa/"},{"categories":["GSEA"],"content":"gseGO gseGO( geneList, ont = \"BP\", OrgDb, keyType = \"ENTREZID\", exponent = 1, minGSSize = 10, maxGSSize = 500, eps = 1e-10, pvalueCutoff = 0.05, pAdjustMethod = \"BH\", verbose = TRUE, seed = FALSE, by = \"fgsea\", ... ) geneList order ranked geneList 根据 logFC(log2folderchange)列进行 降序排列（上调基因在顶部，下调在底部），制作 gene_list集(logFC对应元素名为对应基因id): GSEA_input \u003c- info_merge$Log2FoldChange names(GSEA_input) = info_merge$ENTREZID geneList \u003c- sort(GSEA_input, decreasing = TRUE) gseGO:GO 本体富集，可以进行GO本体的GSEA富集 gsea_go \u003c- gseGO( gene_list, # 根据logFC排序的基因集 ont = \"BP\", # 可选\"BP\"、\"MF\"、\"CC\"三大类或\"ALL\" OrgDb = maize, #orgdb数据库 keyType = \"ENTREZID\", # 基因id类型 pvalueCutoff = 0.05, pAdjustMethod = \"BH\", # p值校正方法 ) 查看分析结果数据和对应列名 head(gsea_go,2) ID ：GO term 或 KEGG 通路 Description ：GO term 描述信息 setSize ：富集到该 term 的基因个数 enrichmentScore ：富集分数，也就是 ES NES ：标准化以后的 ES，全称 normalized enrichment score pvalue：富集的 P 值 p.adjust ：校正后的 P 值 qvalues ：FDR （false discovery rate）错误发现率 rank ：当 ES 最大时，对应基因所在排序好的基因列表中所处的位置 leading_edge：tags 表示核心基因占该通路基因集的百分比；list 表示核心基因占所有基因的百分比；signal，将前 2 项统计值结合在一起计算出的富集信号强度 core_enrichment：核心或者 leading 基因列表。 ","date":"2023-08-29","objectID":"/clusterprofiler_gesa/:1:0","tags":["clusterProfiler","GESA"],"title":"clusterProfiler包GSEA富集","uri":"/clusterprofiler_gesa/"},{"categories":["GSEA"],"content":"上、下调的 GO term 分开展示： dotplot( gsea_go, showCategory=10, split=\".sign\") + facet_grid(.~.sign) ","date":"2023-08-29","objectID":"/clusterprofiler_gesa/:1:1","tags":["clusterProfiler","GESA"],"title":"clusterProfiler包GSEA富集","uri":"/clusterprofiler_gesa/"},{"categories":["“GSEA\""],"content":"基因集富集分析 GSEA 传统KEGG（通路富集分析）和GO（功能富集）分析时，如果富集到的同一通路下，既有上调差异基因，也有下调差异基因，那么这条通路总体的表现形式究竟是怎样？是被抑制还是激活？或者更直观点说，这条通路下的基因表达水平在实验处理后是上升了呢，还是下降了呢? 传统的富集分析，针对总体的差异基因，不区分哪些差异基因是上调还是下调。 上调基因是指在实验组中相对于对照组表达量上升的基因，下调基因是指在实验组中相对于对照组表达量下降的基因。这些基因的变化可能会对生物体的生理和病理状态产生影响。 举个例子，有100个人（差异基因）去参加选秀节目，这里边有唱歌好的，有跳舞好的，有作词好的（各种背景），接着我们按照100个人的身高排序后发现，身高较低的选手大部分被分到了舞蹈组，因此我们获得这样一个结论，身高较低的选手跳舞身体协调性更好！这样，应用到我们的基因功能分析上，就像下图，假如按照差异表达倍数从正到负排序后（Gene set S），我们参与某条通路的差异基因密集排列在排序表顶端（Leading edge subset），及显著上调，因此我们认为这条通路下的基因表达水平在实验处理后是显著上调，可能被激活。 ","date":"2023-08-24","objectID":"/gesa/:0:0","tags":["定义","初体验"],"title":"GSEA简介","uri":"/gesa/"},{"categories":["“GSEA\""],"content":"参考 一文掌握GSEA，超详细教程！ - 知乎 (zhihu.com) 一分钟了解GSEA - 知乎 (zhihu.com) ","date":"2023-08-24","objectID":"/gesa/:1:0","tags":["定义","初体验"],"title":"GSEA简介","uri":"/gesa/"},{"categories":["GWAS"],"content":"GWAS的数据处理和质量控制：学习如何对基因型数据进行格式转换、质量过滤、正负链翻转、基因型填补等操作，以及如何评估数据质量和避免潜在的偏差","date":"2023-08-05","objectID":"/gwas_turtorial/","tags":["数据处理","质量控制"],"title":"Gwas_turtorial","uri":"/gwas_turtorial/"},{"categories":["GWAS"],"content":"GWAS主要步骤 选择一个感兴趣的性状或疾病，以及一个适当的样本群体，如病例和对照组，或者具有连续性状值的个体。 对样本进行全基因组分型，即测定数百万个SNP位点的基因型。 对每个SNP位点进行关联分析，即计算其与性状或疾病的相关性强度和显著性水平，通常使用回归模型或卡方检验等统计方法。 根据设定的显著性阈值，筛选出具有显著关联信号的SNP位点，并绘制曼哈顿图（manhattan plot）来展示全基因组关联结果。 对显著关联信号进行进一步的验证和解释，如进行基因型插补（genotype imputation），精细定位（fine-mapping），功能注释（functional annotation），共定位分析（colocalization analysis）等，以确定最可能的因果变异和相关基因。 ","date":"2023-08-05","objectID":"/gwas_turtorial/:1:0","tags":["数据处理","质量控制"],"title":"Gwas_turtorial","uri":"/gwas_turtorial/"},{"categories":["GWAS"],"content":"GWAS分析基本流程及分析思路 GWAS分析基本流程及分析思路 (qq.com) ","date":"2023-08-05","objectID":"/gwas_turtorial/:2:0","tags":["数据处理","质量控制"],"title":"Gwas_turtorial","uri":"/gwas_turtorial/"},{"categories":["GWAS"],"content":"GWAS的数据QC qc,(quality control)质量控制，比起表观学研究，GWAS研究很少有引起偏差的来源，一般来说，一个人的基因型终其一生几乎不会改变的，因此很少存在同时影响表型又影响基因型的变异。但即便这样，我们在做GWAS时也要去除一些可能引起偏差的因素。 这种因素主要有：群体结构、个体间存在血缘关系、技术性操作。 ","date":"2023-08-05","objectID":"/gwas_turtorial/:3:0","tags":["数据处理","质量控制"],"title":"Gwas_turtorial","uri":"/gwas_turtorial/"},{"categories":["GWAS"],"content":"怎么进行质量控制（PLINK） 质量控制包括两个方向，一个是样本的质量控制，一个是SNP的质量控制 必须先进行SNP过滤，才能进行个体过滤 ??? PLINK 对于PLINK来说，它既可以处理文本格式的文件，也可以处理二进制格式的文件。但是大文本的文件处理起来十分消耗计算资源，所以我们一般 推使用二进制格式的输入文件 。 文本格式的PLINK数据包括两份文件 .ped文件 和 .map文件 ped文件 包含个体信息（例如个体标识符ID，性别等等）以及他们的基因型信息 map文件 包含遗传标记的信息（染色体号，snp号等等） 二进制格式的PLINK数据则包括三份文件 ：.bed文件，.fam文件 和 .bim文件 bed文件 含有 每个个体的识别符（ID） 和每个个体相对应的基因型 fam文件 含有 个体信息 （例如性别之类的） bim文件 含有 遗传标记的信息 （染色体号，snp号等等） PLIINK基础使用命令 plink --bfile MY_DATA --assoc --out gwas_results ‐‐file {your_file}输入文本格式文件 ‐‐bfile {your_file} 输入二进制格式文件 –assoc 关联分析,这一步会对每个SNP和研究者感兴趣的性状进行卡方检验 –out {outfile} 输出文件 样本质量控制 样本的质量控制包括：缺失率、杂合性、基因型性别和记录的性别是否一致。 检测缺失率(个体缺失)，一般将样本缺失率大于5%的个体去除 plink --bfile file --mind 0.05 --make-bed --out file_mind 检测杂合性 plink --bfile file --het --make-bed --out file_het 阈值设置：偏差可能表明样品污染，近亲繁殖。我们建议去除偏离样本的杂合率平均值±3 SD的个体 检测性别不一致的个体 – 受试者信息填写的性别和遗传性别不一致 plink --bfile file --check-sex --make-bed --out file_checksex 将上述筛选出来的不符合的样本去除 plink --bfile file --remove removesample.txt --make-bed --out file_qcsample ","date":"2023-08-05","objectID":"/gwas_turtorial/:3:1","tags":["数据处理","质量控制"],"title":"Gwas_turtorial","uri":"/gwas_turtorial/"},{"categories":["GWAS"],"content":"处理群体分层 ","date":"2023-08-05","objectID":"/gwas_turtorial/:4:0","tags":["数据处理","质量控制"],"title":"Gwas_turtorial","uri":"/gwas_turtorial/"},{"categories":["GWAS"],"content":"参考 一篇手把手教你做GWAS的Guideline文献解读 - 知乎 (zhihu.com) 全基因组关联分析学习资料（GWAS tutorial） - 知乎 (zhihu.com) easyGWAS - Running GWAS easily over the web (mpg.de) ","date":"2023-08-05","objectID":"/gwas_turtorial/:5:0","tags":["数据处理","质量控制"],"title":"Gwas_turtorial","uri":"/gwas_turtorial/"},{"categories":["GWAS"],"content":"2023-8-3新开一坑，开始学GWAS GWAS学习可以分为以下几个板块： GWAS的基本概念和原理：了解GWAS的目的、方法、优势和局限性，以及常用的统计模型和假设检验。 GWAS的数据处理和质量控制：学习如何对基因型数据进行格式转换、质量过滤、正负链翻转、基因型填补等操作，以及如何评估数据质量和避免潜在的偏差。 GWAS的关联分析和结果解读：学习如何使用不同的软件和工具进行关联分析，如何绘制曼哈顿图、QQ图等可视化结果，以及如何根据P值、置信区间、效应大小等指标判断关联性的显著性和强度。 GWAS的后续分析和功能注释：学习如何进行条件分析、Meta分析、基因多效性分析、孟德尔随机化分析等进一步探索关联信号的方法，以及如何利用数据库和工具进行SNP功能注释、基因集富集分析、组织特异性表达分析等方法，以揭示关联信号的生物学意义。 GWAS的文献阅读和案例学习：学习如何阅读和评价GWAS相关的文献，了解不同疾病或性状的GWAS发现和进展，以及如何应用GWAS结果进行风险评估、药物发现等应用。 GWA_tutorial：这是一个GitHub项目，提供了一个在Linux下学习GWAS实操数据的教程，包括四个部分：数据质量控制、群体分层校正、关联分析和多基因风险得分分析。 Genome-wide association studies in R：这是一个R博客文章，提供了一个用R语言分析GWAS的流程，包括数据质量控制、PCA分析、曼哈顿图、QQ图和候选位点功能分析。 ","date":"2023-08-02","objectID":"/gwas/:0:0","tags":["定义","初理解"],"title":"GWAS初体验","uri":"/gwas/"},{"categories":["GWAS"],"content":"GWAS基本概念 GWAS利用全基因组范围内的分子标记，如单核苷酸多态性（SNP），来探索与复杂性状或疾病相关的遗传变异 GWAS的目的是发现与表型变异有统计学关联的基因或基因区域，从而揭示生物学机制和潜在的治疗靶点 ","date":"2023-08-02","objectID":"/gwas/:1:0","tags":["定义","初理解"],"title":"GWAS初体验","uri":"/gwas/"},{"categories":["GWAS"],"content":"SNP 单核苷酸多态性 单核苷酸多态性（SNP）是指DNA序列中单个核苷酸的变异，它是生物遗传多样性的一种重要形式。SNP可以分布在基因的编码区或非编码区，影响基因的功能和表达。SNP也可以用于研究生物的起源、进化、迁移、疾病相关基因和药物反应等方面。 ","date":"2023-08-02","objectID":"/gwas/:2:0","tags":["定义","初理解"],"title":"GWAS初体验","uri":"/gwas/"},{"categories":["GWAS"],"content":"GWAS主要步骤 选择一个感兴趣的性状或疾病，以及一个适当的样本群体，如病例和对照组，或者具有连续性状值的个体。 对样本进行全基因组分型，即测定数百万个SNP位点的基因型。 对每个SNP位点进行关联分析，即计算其与性状或疾病的相关性强度和显著性水平，通常使用回归模型或卡方检验等统计方法。 根据设定的显著性阈值，筛选出具有显著关联信号的SNP位点，并绘制曼哈顿图（manhattan plot）来展示全基因组关联结果。 对显著关联信号进行进一步的验证和解释，如进行基因型插补（genotype imputation），精细定位（fine-mapping），功能注释（functional annotation），共定位分析（colocalization analysis）等，以确定最可能的因果变异和相关基因。 ","date":"2023-08-02","objectID":"/gwas/:3:0","tags":["定义","初理解"],"title":"GWAS初体验","uri":"/gwas/"},{"categories":["GWAS"],"content":"GWAS优势 可以在不依赖先验知识的情况下，全面地探索遗传变异与表型之间的关系，发现一些意想不到的新发现。此外，GWAS可以利用大规模的样本数据和高密度的分子标记，提高统计学效力和解析力 ","date":"2023-08-02","objectID":"/gwas/:4:0","tags":["定义","初理解"],"title":"GWAS初体验","uri":"/gwas/"},{"categories":["GWAS"],"content":"GWAS的局限性 GWAS通常只能解释表型变异中很小一部分的遗传力（heritability），这被称为“丢失的遗传力”（missing heritability）问题。这可能是由于一些罕见变异、结构变异、基因-基因相互作用、基因-环境相互作用等未被GWAS检测到的遗传因素所造成的。 GWAS通常只能发现与表型有关联而非因果关系的变异，这需要通过实验验证或其他方法来进一步证实。此外，GWAS也不能直接提供变异对表型影响的机制和途径，这需要结合其他功能基因组学数据和方法来进行解析。 ","date":"2023-08-02","objectID":"/gwas/:5:0","tags":["定义","初理解"],"title":"GWAS初体验","uri":"/gwas/"},{"categories":["GWAS"],"content":"参考 GWAS研究基本概念1 - 知乎 (zhihu.com) ","date":"2023-08-02","objectID":"/gwas/:6:0","tags":["定义","初理解"],"title":"GWAS初体验","uri":"/gwas/"},{"categories":["R"],"content":"运用代码 keywords \u003c- c(\"calcium\", \"calmodulin\") matched_indices \u003c- sapply(keywords, function(keyword){ str_detect(GO@result$Description, fixed(keyword, ignore_case = T)) }) matched_indices \u003c- apply(matched_indices, 1, any) matched_terms \u003c- GO@result[matched_indices,] ","date":"2023-07-30","objectID":"/23.7.30_r/:1:0","tags":["apply","“str_detect\""],"title":"23.7.30_R","uri":"/23.7.30_r/"},{"categories":["hugo_blog"],"content":"搭建博客记录 ","date":"2023-07-28","objectID":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["hugo","github pages"],"title":"搭建博客","uri":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["hugo_blog"],"content":"选择Hugo\u0026Githubpages的原因 Hugo是一个用Go语言编写的静态网站生成器，它可以快速地创建和发布博客文章。基础运用可以简单，只需要安装Hugo，选择一个主题，编写Markdown格式的文章，然后使用Hugo命令生成静态网站文件，不需要担心数据库、服务器等问题 GitHub Pages是一个静态站点托管服务，直接将个人、组织或项目的页面托管于GitHub库或仓库中。使用GitHub可以创建一个 \u003cusername\u003e.github.io的网站，不需要第一时间考虑域名以及备案等问题，后续有时间可以折腾–更改至自己的域名 GitHub workflow 可以自动更新Hugo 博客，这是一个很方便的功能。只需要将 Hugo 源码 push 到 GitHub 上，就可以触发 GitHub Actions 来生成和部署您的静态网站文件。您不需要在本地运行 Hugo 命令，也不需要手动上传文件到服务器 LoveIt主题个人比较喜欢，相对wordpress上大部分跟简洁，想要花哨也可以自定义魔改主题👴 ","date":"2023-07-28","objectID":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["hugo","github pages"],"title":"搭建博客","uri":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["hugo_blog"],"content":"基于Hugo\u0026Githubpages的博客搭建流程 ","date":"2023-07-28","objectID":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["hugo","github pages"],"title":"搭建博客","uri":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["hugo_blog"],"content":"基本流程 安装 Hugo。可以从[Hugo官网]下载适合您的操作系统的版本，建议下载entende版本（由于很多主题的一些特性需要将 SCSS 转换为 CSS, 推荐使用 Hugo extended版本来获得更好的使用体验 ） 可以使用 hugo version or hugo -h来检验是否安装成功 创建一个新的 Hugo 站点。可以使用 hugo new site path/to/site命令在指定的路径下创建一个空的站点框架 下载主题模板，我使用的是Git 模块方式添加主题到指定文件夹下 git submodule add https://github.com/griedzx/LoveIt.git themes/LoveIt 我将LoveIt模板文件fork到自己的仓库，并使用 git submodule（日后自己个性化模板，可以一键同步更新） 相应设置 config.toml，指定主题、网址，可以参考对应主题中的toml文件 hugo new posts/\u003cxxx\u003e.md创建markdown文件作文博文 hugo serve -D 启动 Hugo server 并使用 drafts 模式，在本地运行一个 web 服务器来预览网站效果，并且可以看到草稿文件的预览 使用GitHub可以创建一个 \u003cusername\u003e.github.io的仓库，将 hugo后产生的 ./public（里面存放的是可部署的静态网站文件）push至对应repo 7.1 GitHub workflow 可以自动更新您的 Hugo 博客，这是一个很方便的功能。只需要将您Hugo 源码 push 到 GitHub 上（可以是另一个repo，也可以是上述repo另一个分支），就可以触发 GitHub Actions 来自动生成和部署的静态网站文件 如果想了解更多关于 GitHub workflow 的信息，您可以参考Host on Github Pages | Hugo ","date":"2023-07-28","objectID":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:1","tags":["hugo","github pages"],"title":"搭建博客","uri":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["hugo_blog"],"content":"设置的tips 文件头扉页 front matter title: \"搭建博客\" date: 2023-07-28T21:57:35+08:00 draft: false hugo一个新md文件一般只会出现前三行设置参数，但是Hugo 将内容分成草稿 Draft，将来发布 Future 和过期 Expired 等类型，可以在文件头扉页 front matter 中设置相应状态。 future 设置 publishdate 值 draft 设置 true 或者 false past 设置 expirydate 值 如 demo.md 文件头扉页 front matter 中设置： --- title: Base Templates and Blocks linktitle: description: The base and block constructs ... godocref: https://golang.org/pkg/text/template/#example_Template_block date: 2017-02-01 publishdate: 2017-02-01 lastmod: 2017-02-01 categories: [templates,fundamentals] keywords: [blocks,base] menu: docs: parent: \"templates\" weight: 20 weight: 20 sections_weight: 20 draft: false aliases: [/templates/blocks/,/templates/base-templates-and-blocks/] toc: true --- 多语言模式 [language]下设置多种参数，具体见多语言模式 |雨 果 (gohugo.io) 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md emoji展示 win10输入法里面 徽标 + 句号（.）可以使用自带的表情符号，可以个性化设置 🐱‍🏍 好玩 以上完成初步hugo网站的搭建，还有很多设置可以学习。hugo官方的汉化版使用文档很简略，大部分网上找到的翻译文档大多直译看完后还是摸不着头脑，在简书上发现Hugo 不完美教程 这一系列教程，使用文档和作者实战经验相结合，对我有很大帮助，我将借助此继续完善我的网站 参考 Hugo 不完美教程 - I: Hugo Web Framework - 简书 (jianshu.com) Hugo框架中文文档 标签分类 - Andbible ","date":"2023-07-28","objectID":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:2","tags":["hugo","github pages"],"title":"搭建博客","uri":"/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["GO\u0026KEGG富集分析"],"content":"问题描述 做GO富集分析时，师姐给的数据是Genome assembly B73 RefGen_v4版本的数据 对应基因id没有需要使用的symbol或者entrez_id形式 并且大多数在线GO分析网站和id转换网站不支持v4版本基因id与symbol或者entrez_id相互转换 Genome assembly B73 RefGen_v4 Genome assembly B73 RefGen_v4是玉米的第四版参考基因组序列，它是由美国农业部农业研究局（USDA-ARS）和美国能源部联合基因组研究所（DOE-JGI）的科学家合作完成的。它是目前最完整、最准确的玉米基因组序列，它包含了21条染色体的端粒到端粒的连续序列，共有2.06亿个碱基对，覆盖了99.8%的可编码区域，注释了39,656个基因。 ","date":"2023-07-18","objectID":"/maize_gene_id%E8%BD%AC%E6%8D%A2/:1:0","tags":["maize_gene_id"],"title":"maize_gene_id转换","uri":"/maize_gene_id%E8%BD%AC%E6%8D%A2/"},{"categories":["GO\u0026KEGG富集分析"],"content":"解决方法 ","date":"2023-07-18","objectID":"/maize_gene_id%E8%BD%AC%E6%8D%A2/:2:0","tags":["maize_gene_id"],"title":"maize_gene_id转换","uri":"/maize_gene_id%E8%BD%AC%E6%8D%A2/"},{"categories":["GO\u0026KEGG富集分析"],"content":"网页在线转换 MaizeGDB gene Search Page MaizeGDB数据库有一个Translate Gene Model IDs工具，可以识别各种类型的玉米的gene_id，并转换为比较常用的几种id(如) ","date":"2023-07-18","objectID":"/maize_gene_id%E8%BD%AC%E6%8D%A2/:2:1","tags":["maize_gene_id"],"title":"maize_gene_id转换","uri":"/maize_gene_id%E8%BD%AC%E6%8D%A2/"},{"categories":["GO\u0026KEGG富集分析"],"content":"爬虫技术解决 R语言爬取NCBI大豆基因Locus tag数据 - 简书 (jianshu.com) 生信笔记01：Locus tag转换为Entrez Gene ID - 简书 (jianshu.com) 通过 ","date":"2023-07-18","objectID":"/maize_gene_id%E8%BD%AC%E6%8D%A2/:2:2","tags":["maize_gene_id"],"title":"maize_gene_id转换","uri":"/maize_gene_id%E8%BD%AC%E6%8D%A2/"},{"categories":["GO\u0026KEGG富集分析"],"content":"AnnotationHub构建OrgDb 要进行GO或者KEGG富集分析，就需要知道每个基因对应什么样的GO/KEGG分类，OrgDb就是存储不同数据库基因ID之间对应关系，以及基因与GO等注释的对应关系的 R 软件包 如果自己研究的物种不在 http://bioconductor.org/packages/release/BiocViews.html#___OrgDb 之列，很大可能就需要自己构建OrgDb，然后用clusterProfiler分析 ","date":"2023-07-17","objectID":"/annotationhub%E6%9E%84%E5%BB%BAorgdb/:0:0","tags":["AnnotationHub","OrgDb"],"title":"Annotationhub构建orgdb","uri":"/annotationhub%E6%9E%84%E5%BB%BAorgdb/"},{"categories":["GO\u0026KEGG富集分析"],"content":"利用AnnotationHub得到org.db 其中一种情况是在（AnnotationHub）中存在对应的注释包 require(AnnotationHub) hub \u003c- AnnotationHub()#下载失败多试几次 query(hub,\"zea mays\") AnnotationHub with 8 records # snapshotDate(): 2023-04-24 # $dataprovider: NCBI,DBCLS, ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/, WikiPathways # $species: Zea mays, Zea mays_var._japonica # $rdataclass: SQLiteFile, OrgDb, Tibble # additional mcols(): taxonomyid, genome, description, coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags, # rdatapath, sourceurl, sourcetype # retrieve records with, e.g., 'object[[\"AH91642\"]]' title AH91642 | MeSHDb for Zea mays (Corn, v001) AH91817 | wikipathways_Zea_mays_metabolites.rda AH97909 | MeSHDb for Zea mays (Corn, v002) AH100374 | MeSHDb for Zea mays (Corn, v003) AH107139 | MeSHDb for Zea mays (Corn, v004) AH111528 | MeSHDb for Zea mays (Corn, v005) AH111691 | org.Zea_mays.eg.sqlite AH111692 | org.Zea_mays_var._japonica.eg.sqlite 阅读命令输出信息，可以看到 数据库来源不同，选择需要的（org）以及确定物种（zea_mays） retrieve records with, e.g., 'object[[\"AH111691\"]]' 检索下载db用指定格式 ","date":"2023-07-17","objectID":"/annotationhub%E6%9E%84%E5%BB%BAorgdb/:1:0","tags":["AnnotationHub","OrgDb"],"title":"Annotationhub构建orgdb","uri":"/annotationhub%E6%9E%84%E5%BB%BAorgdb/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO_KEGG富集分析 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:0:0","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"富集分析 富集分析（ Enrichment Analysis），是一种识别基因集合与已知生物过程、细胞组分和通路之间关联的统计方法。这些工具通过使用数据库中的注释信息来找到对应的基因集合。 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:1:0","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"富集分析的效果、目的 把差异基因或者物质根据其功能进行归类，使具有相似功能的基因或者物质就被放在一起 实现功能和表型相关联 解读一组基因背后所代表的生物学知识，揭示其在细胞内或细胞外扮演了什么样的角色。 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:1:1","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"富集分析的原理 富集分析通常是分析一组基因在某个功能节点上是否相比于随机水平过于出现(over-presentation) ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:1:2","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"常用方法 目前最常用的方法是基于GO和KEGG的富集分析。 首先通过多种方法得到大量的感兴趣的基因，例如差异表达基因集、共表达基因模块、蛋白质复合物基因簇等，然后寻找这些感兴趣基因集显著富集的GO节点或者KEGG通路，这有助于进一步深入细致的实验研究。 依据富集分析过程中基因选择、注释数据库的不同，常用的富集分析可以分为以下四种类型：GO term功能富集、KEGG pathway通路富集、MSigDB基因集富集和单基因富集等等 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:1:3","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO \u0026 KEGG是什么 对于每个基因而言，其基本的功能基于他们的蛋白结构域以及研究的文献已经可以大致的知道一个基因具有什么样子的功能了。GO和KEGG就是基于不同的分类思想而储存的基因相关功能的数据库。 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:2:0","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO数据库 全称是Gene Ontology(基因本体)，他们把基因的功能分成了三个部分分别是： 细胞组分（cellular component, CC）、分子功能（molecular function, MF） 、 生物过程（biological process, BP） 。利用GO数据库，我们就可以得到我们的目标基因在CC, MF和BP三个层面上，主要和什么有关。 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:2:1","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"KEGG数据库 除了对基因本身功能的注释，我们也知道基因会参与人体的各个通路，基于人体通路而形成的数据库就是通路相关的数据库。 京都基因与基因组百科全书（Kyoto encyclopedia of genes and genomes, KEGG）是系统分析基因功能、基因组信息的数据库，整合了基因组学、生物化学及系统功能组学的信息，有助于研究者把基因及表达信息作为一个整体进行研究。目前KEGG共包含了19个子数据库，富集分析常用在KEGG Pathway通路中。 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:2:2","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO_KEGG_GSEA分析 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:3:0","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"下载加载需要的包 下载 install.packages(\"包名称\") 或者 biocManager::install(\"包名称\") BiocManager：是一个 R 包，其中包含了一些用于管理 Bioconductor 包的函数，如 install()、update() 等。使用 :: 表示法，你可以指定调用特定包中的函数。通过 BiocManager，你可以轻松地访问和管理 Bioconductor 存储库中的生物信息学和生物统计学相关的软件包。它简化了安装和维护 Bioconductor 包的过程。 Bioconductor：是一个专门用于生物信息学和生物统计学研究的 R 软件包存储库。它是一个巨大的代码资源库，包含了许多用于基因表达数据分析、基因组学、蛋白质组学等生物学领域的软件包。Bioconductor 提供了丰富的分析工具和算法，能够帮助生物学家处理和解释生物学数据。BiocManager 用于访问和安装 Bioconductor 中的软件包。 :: 不仅可以用于指定调用的包，还可以在不加载整个包的情况下调用该包中的函数。这样可以在特定代码行中临时使用特定包中的函数，而不需要在整个会话中加载该包。:: 只在当前代码行中生效 加载 library(clusterProfiler)#GO\u0026KEGG library(enrichplot)#GO\u0026KEGG library(ggplot2)#柱状图和点状图 library(stringr)#基因ID转换 library(GOplot)#弦图，弦表图，系统聚类图 library(DOSE) library(ggnewscale) library(topGO)#绘制通路网络图 library(circlize)#绘制富集分析圈图 library(ComplexHeatmap)#绘制图例 library(forcats)#绘图中对因子处理 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:3:1","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"读取数据，将基因ID从GENE_SYMBOL转换为ENTREZ_ID #载入数据，只需要基因ID(GO,KEGG,GSEA需要)和log2FOldChange(GSEA(基因集富集分析)需要) data \u003c- read.csv(\"DEG.csv\",header = T) #指定富集分析的物种库 GO_database \u003c- 'org.Hs.eg.db' #GO分析指定物种 KEGG_database \u003c- 'hsa' #KEGG分析指定物种 GO分析指定物种，详见 GO物种缩写索引表 KEGG分析指定物种，详见 keggle物种缩写索引表 #安装注释数据库 if (!require(\"BiocManager\", quietly = TRUE)) install.packages(\"BiocManager\") BiocManager::install(\"org.Hs.eg.db\") 有问题参见官网 Bioconductor - org.Hs.eg.db OrgDb org数据库是一个用于存储特定物种的基因和基因注释信息的数据库。每个org数据库专门用于一个特定的生物物种，例如人类、小鼠、大鼠等。org数据库包含了与该物种相关的基因、基因产物以及它们的注释信息，如基因的功能、组织表达、基因本体注释等。在生物学研究中，研究人员经常需要将基因与GO术语相关联，从而了解基因的功能和参与的生物过程。为此，他们需要使用org数据库中的基因注释信息，将基因与GO术语进行映射，以便进行GO富集分析、基因集对比等功能。 在 http://bioconductor.org/packages/release/BiocViews.html#___OrgDb可以找到对应物种 #gene ID转换 gene \u003c- bitr(data$gene,fromType = 'SYMBOL', toType = 'ENTREZID',OrgDb = GO_database) 如果自己研究的物种不在 http://bioconductor.org/packages/release/BiocViews.html#___OrgDb 之列，很大可能就需要自己构建OrgDb，然后用clusterProfiler分析。非模式生物要想找到自己的注释包，又分成两类： 一类是在 AnnotationHub 中存在的，例如玉米 另一类是在AnnotationHub也不存在相应物种，就需要用 AnnotationForge 来自己构建 若出现 \u003e gene \u003c- bitr(data$gene,fromType = 'SYMBOL', toType = 'ENTREZID',OrgDb = GO_database) 'select()' returned 1:many mapping between keys and columns Warning message: In bitr(data$gene, fromType = \"SYMBOL\", toType = \"ENTREZID\", OrgDb = GO_database) : 0.7% of input gene IDs are fail to map... 一对多映射：某些基因 ID（SYMBOL）可能对应多个基因 ID（ENTREZID）。这种情况通常是因为一个基因可能有多个变体或不同的数据库中存在多个记录。 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:3:2","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO分析 #GO分析 GO \u003c- enrichGO(gene$ENTREZID, OrgDb = GO_database, keyType = \"ENTREZID\",#设定读取的gene ID类型 ont = 'ALL', #ont=all即包括GO数据库中的三个部分CC、MF、BP pvalueCutoff = 0.05, qvalueCutoff = 0.05, readable = T) readable 参数用于控制 GO 富集分析结果中的基因 ID 是否转换成易读的描述性名称,即ENTREZ_ID -\u003e SYMBOL_ID,默认为 False ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:3:3","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"KEGG分析 （参数和GO差不多） KEGG \u003c- enrichKEGG(gene$ENTREZID,#KEGG富集分析 organism = KEGG_database, pvalueCutoff = 0.05, qvalueCutoff = 0.05) GO \u0026 KEGG 都可以保存为csv文件查看 write.csv(GO,\"./result.csv\") GO_result \u003c- GO@result 所得变量存储格式和输出文件格式相同，可以查看选择感兴趣的定制画图 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:3:4","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO \u0026 KEGG结果可视化 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:4:0","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"富集柱状图 + 点状图 barplot(GO, split = \"ONTOLOGY\") + facet_grid(ONTOLOGY~., scale = \"free\") + scale_y_discrete(labels=function(x) str_wrap(x, width = 100)) dotplot(GO, split = \"ONTOLOGY\") + facet_grid(ONTOLOGY~., scale = \"free\") barplot() 函数用于创建柱状图 参数 split = \"ONTOLOGY\" 表示按照 “ONTOLOGY” 列的不同取值（GO_db的三个层面）将数据拆分为不同的柱状图 facet_grid() 函数用于将拆分后的柱状图按照 “ONTOLOGY” 列的不同取值排列在一个网格中。每一行代表一个 “ONTOLOGY” 类别 子图根据数据的分布自动调整高度，即参数 scale = \"free\"，以便更好地展示数据的差异 barplot(GO, showCategory=20) 参数 showCategory 可以控制展示的数量 scale_y_discrete(labels=function(x) str_wrap(x, width = 100)) #调整y轴标签长度，使其放在一行 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:4:1","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"棒棒糖图 ggplot(GO, showCategory = 20, aes(GeneRatio, fct_reorder(Description, GeneRatio))) + geom_segment(aes(xend=0, yend = Description)) + geom_point(aes(color=p.adjust, size = Count)) + scale_color_viridis_c(guide=guide_colorbar(reverse=TRUE)) + scale_size_continuous(range=c(2, 10)) + theme_minimal() + ylab(NULL) aes(GeneRatio, fct_reorder(Description, GeneRatio)): 这里设置了图形的\"美学映射\"（aesthetic mappings） GeneRatio 是x轴的变量，fct_reorder(Description, GeneRatio) 是y轴的变量 fct_reorder() 函数可以根据 GeneRatio 的值对 Description 进行重新排序，这样可以根据 GeneRatio 的大小对y轴的标签进行排列。 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:4:2","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"富集基因与所在功能集/通路集的关联网络图 enrichplot::cnetplot(GO, circular = F, colorEdge = T) circluar为指定是否环化，基因过多建议设置成 F ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:4:3","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"富集到的功能集/通路集之间的关联网络图 GO2 \u003c- pairwise_termsim(GO) enrichplot::emapplot(GO2,showCategory = 50, color = \"p.adjust\", layout = \"kk\")#通路间关联网络图 热图展现关联关系 enrichplot::heatplot(GO,showCategory = 50)#基因-通路关联热图 enrichplot::heatplot(KEGG,showCategory = 50) ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:4:4","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO富集功能网络图 GO_BP\u003c-enrichGO( gene$ENTREZID,#GO富集分析BP模块 OrgDb = GO_database, keyType = \"ENTREZID\", ont = \"BP\", pvalueCutoff = 0.05, pAdjustMethod = \"BH\", qvalueCutoff = 0.05, minGSSize = 10, maxGSSize = 500, readable = T) plotGOgraph(GO_BP)#GO-BP功能网络图 GO_CC\u003c-enrichGO( gene$ENTREZID,#GO富集分析CC模块 OrgDb = GO_database, keyType = \"ENTREZID\", ont = \"CC\", pvalueCutoff = 0.05, pAdjustMethod = \"BH\", qvalueCutoff = 0.05, minGSSize = 10, maxGSSize = 500, readable = T) plotGOgraph(GO_CC)#GO-CC功能网络图 GO_MF\u003c-enrichGO( gene$ENTREZID,#GO富集分析MF模块 OrgDb = GO_database, keyType = \"ENTREZID\", ont = \"MF\", pvalueCutoff = 0.05, pAdjustMethod = \"BH\", qvalueCutoff = 0.05, minGSSize = 10, maxGSSize = 500, readable = T) plotGOgraph(GO_MF)#GO-MF功能网络图 ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:4:5","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"GO富集弦图 先要将所有GO富集到的基因集所对应的类型写入本地文件从而得到BP/CC/MF各自的起始位置如我的数据里是1，2103，2410. genedata\u003c-data.frame(ID=info$gene_symbol,logFC=info$log2FoldChange) write.table(GO$ONTOLOGY, file = \"/Users/ZYP/Downloads/KEGG_GO/GO_ONTOLOGYs.txt\", #将所有GO富集到的基因集所对应的类型写入本地文件从而得到BP/CC/MF各自的起始位置如我的数据里是1，2103，2410 append = FALSE, quote = TRUE, sep = \" \", eol = \"\\n\", na = \"NA\", dec = \".\", row.names = TRUE, col.names = TRUE, qmethod = c(\"escape\", \"double\"), fileEncoding = \"\") GOplotIn_BP\u003c-GO[1:10,c(2,3,7,9)] #提取GO富集BP的前10行,提取ID,Description,p.adjust,GeneID四列 GOplotIn_CC\u003c-GO[2103:2112,c(2,3,7,9)]#提取GO富集CC的前10行,提取ID,Description,p.adjust,GeneID四列 GOplotIn_MF\u003c-GO[2410:2419,c(2,3,7,9)]#提取GO富集MF的前10行,提取ID,Description,p.adjust,GeneID四列 GOplotIn_BP$geneID \u003c-str_replace_all(GOplotIn_BP$geneID,'/',',') #把GeneID列中的’/’替换成‘,’ GOplotIn_CC$geneID \u003c-str_replace_all(GOplotIn_CC$geneID,'/',',') GOplotIn_MF$geneID \u003c-str_replace_all(GOplotIn_MF$geneID,'/',',') names(GOplotIn_BP)\u003c-c('ID','Term','adj_pval','Genes')#修改列名,后面弦图绘制的时候需要这样的格式 names(GOplotIn_CC)\u003c-c('ID','Term','adj_pval','Genes') names(GOplotIn_MF)\u003c-c('ID','Term','adj_pval','Genes') GOplotIn_BP$Category = \"BP\"#分类信息 GOplotIn_CC$Category = \"CC\" GOplotIn_MF$Category = \"MF\" circ_BP\u003c-GOplot::circle_dat(GOplotIn_BP,genedata) #GOplot导入数据格式整理 circ_CC\u003c-GOplot::circle_dat(GOplotIn_CC,genedata) circ_MF\u003c-GOplot::circle_dat(GOplotIn_MF,genedata) chord_BP\u003c-chord_dat(data = circ_BP,genes = genedata) #生成含有选定基因的数据框 chord_CC\u003c-chord_dat(data = circ_CC,genes = genedata) chord_MF\u003c-chord_dat(data = circ_MF,genes = genedata) GOChord(data = chord_BP,#弦图 title = 'GO-Biological Process',space = 0.01,#GO Term间距 limit = c(1,1),gene.order = 'logFC',gene.space = 0.25,gene.size = 5, lfc.col = c('red','white','blue'), #上下调基因颜色 process.label = 10) #GO Term字体大小 GOChord(data = chord_CC,title = 'GO-Cellular Component',space = 0.01, limit = c(1,1),gene.order = 'logFC',gene.space = 0.25,gene.size = 5, lfc.col = c('red','white','blue'), process.label = 10) GOChord(data = chord_MF,title = 'GO-Mollecular Function',space = 0.01, limit = c(1,1),gene.order = 'logFC',gene.space = 0.25,gene.size = 5, lfc.col = c('red','white','blue'), process.label = 10) ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:4:6","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":["GO\u0026KEGG富集分析"],"content":"参考文章 GO分析和KEGG分析都是啥？ - 知乎 (zhihu.com) 最全的GO, KEGG, GSEA分析教程(R),你要的高端可视化都在这啦！[包含富集圈图] - 知乎 (zhihu.com) ","date":"2023-07-16","objectID":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/:5:0","tags":null,"title":"Go_kegg富集分析","uri":"/go_kegg%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/"},{"categories":null,"content":"自我简介 大家好，我是griedzx，一名大概率喜欢生物信息学的学生，对于生物学和计算机科学的结合产生了浓厚的兴趣，我希望通过写博客来分享我在生物信息学领域的学习心得和经验。 ","date":"2023-06-17","objectID":"/about/:1:0","tags":["about me"],"title":"About","uri":"/about/"},{"categories":null,"content":"学习和技能 生物学基础：我在生物学领域有扎实的基础知识，包括分子生物学、遗传学和生物信息学的基本概念。 编程语言：我熟悉Python编程语言，并且在生物信息学领域中有丰富的编程实践经验。 生物信息学工具：我熟悉常用的生物信息学工具和软件，如BLAST、Bowtie、Samtools等，可以进行基本的序列分析和基因组学研究。 数据分析：我了解常见的数据分析方法和统计学原理，并能够使用相关的工具和库进行生物信息数据的处理和分析。 ","date":"2023-06-17","objectID":"/about/:2:0","tags":["about me"],"title":"About","uri":"/about/"},{"categories":null,"content":"目标 作为一名生物信息专业的学生，我希望在未来能够做出以下贡献： 深入学习和理解生物信息学的前沿技术和方法，如基因组学、转录组学和蛋白质组学等。 运用生物信息学工具和技术解决生物学研究中的实际问题，例如寻找基因突变、预测蛋白质结构等。 参与生物信息学项目，与团队合作并交流学习，推动生物信息学在生命科学研究中的应用。 继续学习和探索相关的计算机科学知识和技术，如机器学习和人工智能在生物信息学中的应用。 ","date":"2023-06-17","objectID":"/about/:3:0","tags":["about me"],"title":"About","uri":"/about/"},{"categories":null,"content":"博客主题 我将在我的博客上分享以下主题： 生物信息学入门指南和基础知识解析。 常用生物信息学工具和软件的介绍和使用技巧。 生物信息学研究方法和数据分析技术的分享。 前沿的生物信息学应用和研究进展的介绍和评论。 生物信息学与其他学科交叉的领域探索，如计算系统生物学和药物设计等。 如果你对以上任何主题感兴趣，欢迎订阅我的博客或在文章下方留言交流。 希望通过我的博客，能够帮助更多的人了解和应用生物信息学，推动生命科学研究的发展。非常感谢你阅读我的第一篇博客文章，期待在未来与你的交流和分享！ ","date":"2023-06-17","objectID":"/about/:4:0","tags":["about me"],"title":"About","uri":"/about/"}]